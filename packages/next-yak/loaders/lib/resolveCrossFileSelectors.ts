import path from "path";
import babel from "@babel/core";
// This let's vite bundle this dependency correctly (used for the playground)
// @ts-expect-error - this should be a dynamic import
import babelPlugin from "@babel/plugin-syntax-typescript";
import type { Compilation, LoaderContext } from "webpack";
import { getCssModuleLocalIdent } from "next/dist/build/webpack/config/blocks/css/loaders/getCssModuleLocalIdent.js";

export async function resolveCrossFileSelectors(
  loader: LoaderContext<{}>,
  css: string
): Promise<string> {
  // Search for :module-selector-import(FOO from 'bar')
  // generated by the yak babel plugin
  const moduleSelectorRegex =
    /:module-selector-import\(([^)]+) from '([^']+)'\)/g;
  const matches = [...css.matchAll(moduleSelectorRegex)];
  const firstMatchPosition = matches[0]?.index;
  if (firstMatchPosition === undefined) {
    return css;
  }
  let result = "";
  // Reverse itereate to replace from the end
  for (let i = matches.length - 1; i >= 0; i--) {
    const match = matches[i];
    const index = match.index;
    if (index === undefined) {
      throw new Error("Match index is undefined");
    }
    const namedExport = match[1];
    const importPath = match[2];

    const resolved = await resolveIdentifier(
      loader,
      loader.context,
      importPath,
      namedExport
    );
    // should be the internal namedExport identifier not the exported one
    const selector = `:global(.${getCssModuleLocalIdent(
      {
        rootContext: loader.rootContext,
        resourcePath: resolved.from,
      },
      null,
      resolved.name,
      {}
    )})`;
    result = selector + css.slice(index + match[0].length) + result;
  }
  result = css.slice(0, firstMatchPosition) + result;
  return result;
}

async function resolveIdentifier(
  loader: LoaderContext<{}>,
  context: string,
  sourcePath: string,
  identifier: string
): Promise<{
  name: string;
  from: string;
}> {
  const resolved = await new Promise<string>((resolve, reject) => {
    loader.resolve(context, sourcePath, (err, result) => {
      if (err) {
        return reject(err);
      }
      if (!result) {
        return reject(new Error(`Could not resolve ${sourcePath}`));
      }
      resolve(result);
    });
  });
  loader.addDependency(resolved);
  const exports = await getAllExports(
    loader,
    resolved,
    resolved.endsWith(".tsx")
  );
  const exportForIdentifier = exports[identifier];
  if (!exportForIdentifier) {
    throw new Error(`Could not find export ${identifier} in ${resolved}`);
  }
  if (typeof exportForIdentifier === "string") {
    return {
      name: exportForIdentifier,
      from: resolved,
    };
  }
  const result = resolveIdentifier(
    loader,
    path.dirname(resolved),
    exportForIdentifier.from,
    exportForIdentifier.name
  );
  return result;
}

/**
 *  Cache the exports per file name to avoid parsing the same file multiple times
 */
const exportsCache = new WeakMap<
  Compilation,
  Map<string, Record<string, string | { name: string; from: string }>>
>();

/**
 * Use babel together with the "@babel/plugin-syntax-typescript" to extract all exports from a typescript file
 */
async function getAllExports(
  loader: LoaderContext<{}>,
  source: string,
  isTSX: boolean
): Promise<{ [key: string]: string | { name: string; from: string } }> {
  const compilationCache =
    loader._compilation && exportsCache.get(loader._compilation)?.get(source);
  if (compilationCache) {
    return compilationCache;
  }

  const sourceContents = await new Promise<string>((resolve, reject) =>
    loader.fs.readFile(source, "utf-8", (err, result) => {
      if (err) {
        return reject(err);
      }
      resolve(result || "");
    })
  );

  let result: { [key: string]: string | { name: string; from: string } } = {};
  babel.transformSync(sourceContents, {
    configFile: false,
    plugins: [
      [babelPlugin, { isTSX }],
      [
        (): babel.PluginObj => ({
          visitor: {
            ExportNamedDeclaration({ node }) {
              // reexports e.g. export { Baz as Bar } from "./foo"
              if (node.source) {
                node.specifiers.forEach((specifier) => {
                  const exportSource = node.source?.value;
                  if (
                    specifier.exported.type === "Identifier" &&
                    specifier.exported.name &&
                    specifier.type === "ExportSpecifier" &&
                    specifier.local.type === "Identifier" &&
                    specifier.local.name &&
                    exportSource
                  ) {
                    result[specifier.exported.name] = {
                      name: specifier.local.name,
                      from: exportSource,
                    };
                  }
                });
              } // named export e.g. export const Foo = 1
              else if (node.declaration?.type === "VariableDeclaration") {
                node.declaration.declarations.forEach((declaration) => {
                  if (
                    declaration.id.type === "Identifier" &&
                    declaration.id.name
                  ) {
                    // TODO: check if this is a styled component, or constant, or sth unsupported
                    result[declaration.id.name] = declaration.id.name;
                  }
                });
              }
            },
            ExportDefaultDeclaration() {
              // TODO: add support for default exports
            },
          },
        }),
      ],
    ],
  });
  if (loader._compilation) {
    const compilationCache = exportsCache.get(loader._compilation);
    const exportsPerFile = compilationCache || new Map();
    exportsPerFile.set(source, result);
    if (!compilationCache) {
      exportsCache.set(loader._compilation, exportsPerFile);
    }
  }
  return result;
}
