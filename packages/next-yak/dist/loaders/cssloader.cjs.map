{"version":3,"sources":["../../loaders/lib/getConstantValues.ts","../../loaders/lib/hash.ts","../../loaders/lib/replaceQuasiExpressionTokens.ts","../../loaders/lib/getStyledComponentName.ts","../../loaders/lib/getCssName.ts","../../loaders/lib/parseCss.ts","../../loaders/lib/toCss.ts","../../loaders/lib/appendCssUnitToExpressionValue.ts","../../loaders/babel-yak-plugin.ts","../../loaders/cssloader.ts","../../loaders/tsloader.ts","../../loaders/lib/getYakImports.ts"],"sourcesContent":["import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Returns the name of the expression\n */\nexport const getConstantName = (\n  expression: babelTypes.Expression,\n  t: typeof babelTypes\n) => {\n  // e.g. styled.div`color: ${x};`\n  if (t.isIdentifier(expression)) {\n    // e.g. x\n    return expression.name;\n  } else if (\n    t.isMemberExpression(expression) &&\n    t.isIdentifier(expression.object)\n  ) {\n    // e.g. x for x.y\n    return expression.object.name;\n  } else if (\n    t.isCallExpression(expression) &&\n    t.isIdentifier(expression.callee)\n  ) {\n    // e.g. x for x()\n    return expression.callee.name;\n  } else if (\n    t.isCallExpression(expression) &&\n    t.isMemberExpression(expression.callee) &&\n    t.isIdentifier(expression.callee.object)\n  ) {\n    // e.g. x for x.y()\n    return expression.callee.object.name;\n  } else {\n    return null;\n  }\n};\n\n/**\n * Extracts all top level constant values from a program path\n */\nexport function getConstantValues(\n  path: NodePath<babelTypes.Program>,\n  t: typeof babelTypes\n) {\n  const topLevelConstBindings = new Map<\n    string,\n    | {\n        value: string | number | null;\n        type: \"variable\";\n      }\n    | {\n        value: null;\n        type: \"module\" | \"function\";\n      }\n  >();\n  const bindings = Object.entries(path.scope.bindings);\n  for (const [name, binding] of bindings) {\n    if (binding.kind === \"module\") {\n      topLevelConstBindings.set(name, {\n        value: null,\n        type: \"module\",\n      });\n      continue;\n    }\n    if (\n      binding.kind === \"let\" ||\n      binding.kind === \"var\" ||\n      binding.kind === \"const\"\n    ) {\n      // variable without value e.g. let x;\n      if (!(\"init\" in binding.path.node)) {\n        topLevelConstBindings.set(name, {\n          type: \"variable\",\n          value: null,\n        });\n        continue;\n      }\n      const value = binding.path.node.init;\n      // don't consider function declarations or arrow functions as constants\n      if (\n        t.isFunctionDeclaration(value) ||\n        t.isArrowFunctionExpression(value)\n      ) {\n        topLevelConstBindings.set(name, {\n          type: \"function\",\n          value: null,\n        });\n        continue;\n      }\n      topLevelConstBindings.set(name, {\n        type: \"variable\",\n        value:\n          t.isStringLiteral(value) || t.isNumericLiteral(value)\n            ? value.value\n            : null,\n      });\n    }\n  }\n  return topLevelConstBindings;\n}\n","/**\n * JS Implementation of MurmurHash2\n *\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n *\n * @param str ASCII only\n * @return Base 36 encoded hash result\n */\nexport default function murmurhash2_32_gc(str: string) {\n  let l = str.length;\n  let h = l;\n  let i = 0;\n  let k;\n\n  while (l >= 4) {\n    k =\n      (str.charCodeAt(i) & 0xff) |\n      ((str.charCodeAt(++i) & 0xff) << 8) |\n      ((str.charCodeAt(++i) & 0xff) << 16) |\n      ((str.charCodeAt(++i) & 0xff) << 24);\n\n    k =\n      (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n    k ^= k >>> 24;\n    k =\n      (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n\n    h =\n      ((h & 0xffff) * 0x5bd1e995 +\n        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^\n      k;\n\n    l -= 4;\n    ++i;\n  } // forgive existing code\n\n  /* eslint-disable no-fallthrough */ switch (l) {\n    case 3:\n      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n    case 2:\n      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n    case 1:\n      h ^= str.charCodeAt(i) & 0xff;\n      h =\n        (h & 0xffff) * 0x5bd1e995 +\n        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n  }\n  /* eslint-enable no-fallthrough */\n\n  h ^= h >>> 13;\n  h = (h & 0xffff) * 0x5bd1e995 + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n  h ^= h >>> 15;\n\n  return (h >>> 0).toString(36);\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Replace tokens with predefined values e.g.\n *\n * ```js\n *  css`\n *    color: red;\n *    ${query.xs} {\n *      color: blue;\n *   }\n * `\n *\n * ```\n * becomes\n * ```js\n * css`\n *  color: red;\n *  @media (min-width: 0px) {\n *    color: blue;\n * }\n * `\n * ```\n */\nexport default function replaceTokensInQuasiExpressions(\n  quasi: babelTypes.TemplateLiteral,\n  replacer: (name: string) => unknown,\n  t: typeof babelTypes\n) {\n  // Iterate over the expressions in reverse order\n  // so removing items won't affect the index of the next item\n  for (let i = quasi.expressions.length - 1; i >= 0; i--) {\n    const expression = quasi.expressions[i];\n    // break the expression into parts\n    // e.g. x.y.z -> [\"x\", \"y\", \"z\"]\n    const parts = getExpressionParts(expression, t);\n    // find the replacement for the expression\n    const replacement = parts && replacer(parts[0]);\n    // if it is a nested value, find the value of the expression\n    // e.g. x.y.z -> find the value of z\n    const replacementValue =\n      replacement && getReplacementValue(replacement, parts);\n    if (replacementValue !== false && replacementValue !== null) {\n      replaceExpressionAndMergeQuasis(quasi, i, replacementValue);\n    }\n  }\n}\n\n/**\n * Replace tokens with predefined values\n */\nfunction replaceExpressionAndMergeQuasis(\n  quasi: babelTypes.TemplateLiteral,\n  expressionIndex: number,\n  replacement: unknown\n) {\n  const stringReplacement =\n    typeof replacement === \"string\"\n      ? replacement\n      : replacement == null\n      ? \"\"\n      : JSON.stringify(replacement);\n  quasi.expressions.splice(expressionIndex, 1);\n  quasi.quasis[expressionIndex].value.raw +=\n    stringReplacement + quasi.quasis[expressionIndex + 1].value.raw;\n  quasi.quasis[expressionIndex].value.cooked +=\n    stringReplacement + quasi.quasis[expressionIndex + 1].value.cooked;\n  quasi.quasis.splice(expressionIndex + 1, 1);\n}\n\n/**\n * Find the replacement for the expression\n *\n * searches for:\n *   - `x` -> [\"x\"]\n *   - `x.y` -> [\"x\", \"y\"]\n *   - `x[0]` -> [\"x\", 0]\n *   - `x()` -> [\"x\"]\n *   - `x.y()` -> [\"x\", \"y\"]\n *   - (1 + 2) -> null\n */\nfunction getExpressionParts(\n  expression: babelTypes.Expression | babelTypes.TSType,\n  t: typeof babelTypes\n) {\n  let currentExpression = expression;\n  /** @type {string[]} */\n  const tokens = [];\n  while (currentExpression) {\n    // e.g. x\n    if (t.isIdentifier(currentExpression)) {\n      tokens.unshift(currentExpression.name);\n      break;\n    }\n    // e.g. x.y\n    if (t.isMemberExpression(currentExpression)) {\n      if (\n        currentExpression.computed === false &&\n        t.isIdentifier(currentExpression.property)\n      ) {\n        tokens.unshift(currentExpression.property.name);\n      } else if (t.isStringLiteral(currentExpression.property)) {\n        tokens.unshift(currentExpression.property.value);\n      } else if (t.isNumericLiteral(currentExpression.property)) {\n        tokens.unshift(String(currentExpression.property.value));\n      } else {\n        return null;\n      }\n      currentExpression = currentExpression.object;\n    } else if (t.isCallExpression(currentExpression)) {\n      if (!t.isExpression(currentExpression.callee)) {\n        return null;\n      }\n      currentExpression = currentExpression.callee;\n    } else {\n      return null;\n    }\n  }\n  return tokens;\n}\n\n/**\n * Get the value of the replacement\n *\n * e.g. for `replacement.x.y[0]` and `replacement = { x: { y: [42] } }`\n * parts = [\"replacement\", \"x\", \"y\", 0]\n * --> 42\n */\nfunction getReplacementValue(replacement: any, parts: string[]) {\n  let currentReplacement = replacement;\n  for (let i = 1; i < parts.length; i++) {\n    const part = parts[i];\n    if (currentReplacement == null || typeof currentReplacement !== \"object\") {\n      return false;\n    }\n    currentReplacement = currentReplacement[part];\n  }\n  return currentReplacement;\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Try to get the name of a styled component from a call or member expression\n *\n * e.g. const MyButton = styled.div`...` -> \"MyButton\"\n * e.g. const FancyButton = styled(MyButton)`...` -> \"FancyButton\"\n */\nconst getStyledComponentName = (\n  taggedTemplateExpressionPath: NodePath<babelTypes.TaggedTemplateExpression>\n) => {\n  const variableDeclaratorPath = taggedTemplateExpressionPath.findParent(\n    (path) => path.isVariableDeclarator()\n  );\n  if (\n    !variableDeclaratorPath ||\n    !(\"id\" in variableDeclaratorPath.node) ||\n    variableDeclaratorPath.node.id?.type !== \"Identifier\"\n  ) {\n    throw new Error(\n      \"Could not find variable declaration for styled component at \" +\n        taggedTemplateExpressionPath.node.loc\n    );\n  }\n  return variableDeclaratorPath.node.id.name;\n};\n\nexport default getStyledComponentName;\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Extracts the conditions from a path\n */\nfunction extractConditions(\n  path: NodePath<babelTypes.TaggedTemplateExpression>\n) {\n  const conditions: string[] = [];\n  const visitedNodes = new Set();\n  const getConditions = (\n    node: babelTypes.Node,\n    previousNode: babelTypes.Node,\n    isNegated = false\n  ) => {\n    if (visitedNodes.has(node)) return;\n    visitedNodes.add(node);\n    // Support for && and || operators e.g. disabled && \"disabled\"\n    if (node.type === \"LogicalExpression\") {\n      if (node.operator === \"&&\") {\n        getConditions(node.right, previousNode, isNegated);\n        conditions.push(\"and\");\n        getConditions(node.left, previousNode, isNegated);\n      } else if (node.operator === \"||\") {\n        getConditions(node.right, previousNode, isNegated);\n        conditions.push(\"or\");\n        getConditions(node.left, previousNode, isNegated);\n      }\n    }\n    // Support for ternary operator e.g. disabled ? \"disabled\" : \"enabled\"\n    else if (node.type === \"ConditionalExpression\") {\n      conditions.push(\"and\");\n      getConditions(node.test, previousNode, node.alternate === previousNode);\n    }\n    // Support for ! operator e.g. !disabled\n    else if (node.type === \"UnaryExpression\" && node.operator === \"!\") {\n      getConditions(node.argument, previousNode, !isNegated);\n    }\n    // Support for Boolean() function e.g. Boolean(disabled)\n    else if (\n      node.type === \"CallExpression\" &&\n      node.callee.type === \"Identifier\" &&\n      node.callee.name === \"Boolean\"\n    ) {\n      getConditions(node.arguments[0], previousNode, isNegated);\n    }\n    // Get the name of the variable e.g. disabled\n    else if (node.type === \"Identifier\") {\n      conditions.push((isNegated ? \"not_\" : \"\") + node.name);\n    }\n    // Get the name of a member expression e.g. props.disabled\n    else if (node.type === \"MemberExpression\") {\n      conditions.push(\n        (isNegated ? \"not_\" : \"\") + getMemberExpressionName(node)\n      );\n    }\n  };\n  let currentPath: NodePath | null = path;\n  let previousPath: NodePath = path;\n  while (currentPath) {\n    getConditions(currentPath.node, previousPath.node);\n    previousPath = currentPath;\n    currentPath = currentPath.parentPath;\n  }\n  if (conditions[0] === \"or\" || conditions[0] === \"and\") {\n    conditions.shift();\n  }\n  return conditions.reverse();\n}\n\n/**\n * Try to get the name of a css component from a literal expression\n *\n * e.g. const mixin = css`...` -> \"mixin\"\n */\nconst getStyledComponentName = (\n  taggedTemplateExpressionPath: NodePath<babelTypes.TaggedTemplateExpression>\n) => {\n  const variableDeclaratorPath = taggedTemplateExpressionPath.findParent(\n    (path) => path.isVariableDeclarator()\n  );\n  if (\n    !variableDeclaratorPath ||\n    !(\"id\" in variableDeclaratorPath.node) ||\n    variableDeclaratorPath.node.id?.type !== \"Identifier\"\n  ) {\n    return null;\n  }\n  return variableDeclaratorPath.node.id.name;\n};\n\n/**\n * Try to get the name of a member expression\n *\n * e.g. props.disabled -> \"propsDisabled\"\n * e.g. props.user.disabled -> \"propsUserDisabled\n */\nfunction getMemberExpressionName(node: babelTypes.MemberExpression): string {\n  if (\n    !node.object ||\n    !node.property ||\n    (node.object.type !== \"Identifier\" &&\n      node.object.type !== \"MemberExpression\")\n  ) {\n    return \"\";\n  }\n  const objectName =\n    node.object.type === \"Identifier\"\n      ? node.object.name\n      : getMemberExpressionName(node.object);\n  const property = node.property;\n  let propertyName = \"\";\n  if (property.type === \"Identifier\") {\n    propertyName = property.name;\n  } else if (property.type === \"StringLiteral\") {\n    propertyName = property.value;\n  }\n  if (!propertyName) {\n    return \"\";\n  }\n  return objectName + propertyName[0].toUpperCase() + propertyName.slice(1);\n}\n\n/**\n * Try to get the name of a css literal\n *\n * e.g. ({$disabled}) => $disabled && css`...` -> \"is_$disabled\"\n */\nexport default function getCssName(\n  literal: NodePath<babelTypes.TaggedTemplateExpression>\n) {\n  const conditions = extractConditions(literal);\n  if (conditions.length === 0) {\n    const mixinName = getStyledComponentName(literal);\n    return mixinName ? mixinName : \"yak\";\n  }\n  return conditions.join(\"_\").replace(/\\$/g, \"\");\n}\n","export interface ParserState {\n    isInsideString: \"'\" | '\"' | false;\n    isInsideComment: boolean;\n    isInsidePropertyValue: boolean;\n    isInsideAtRule: boolean;\n    currentScopes: CssScope[];\n    currentDeclaration: Declaration;\n  }\n  \n  export interface CssScope {\n    name: string;\n    type: 'at-rule' | 'selector';\n  }\n  \n  export interface Declaration {\n    property: string;\n    value: string;\n    scope: CssScope[];\n    closed: boolean;\n  }\n  \n  const newDeclaration = (): Declaration => ({\n    scope: [],\n    property: '',\n    value: '',\n    closed: false,\n  });\n  \n  /**\n   * A function that parses a string of CSS and returns the state of the parser after parsing the string.\n   * Useful for parsing incomplete CSS strings.\n   */\n  export function parseCss(\n    cssString: string,\n    initialState: ParserState = {\n      isInsideString: false,\n      isInsideComment: false,\n      isInsidePropertyValue: false,\n      isInsideAtRule: false,\n      currentScopes: [],\n      currentDeclaration: newDeclaration(),\n    }\n  ): { state: ParserState; declarations: Declaration[] } {\n    let isInsideString: \"'\" | '\"' | false = initialState.isInsideString;\n    let isInsideComment = initialState.isInsideComment;\n    let isInsidePropertyValue = initialState.isInsidePropertyValue;\n    let currentScopes = [...initialState.currentScopes];\n    let currentCode = '';\n    let isInsideAtRule = initialState.isInsideAtRule;\n    let currentDeclaration: Declaration = { ...initialState.currentDeclaration, scope: currentScopes };\n    let backSlashes = 0;\n    const declarations: Declaration[] = [currentDeclaration];\n  \n    // Iterate over the CSS string character by character\n    for (let index = 0; index < cssString.length; index++) {\n      let previousBackSlashes = backSlashes;\n      const currentCharacter = cssString[index];\n      if (currentCharacter === '\\\\') {\n        backSlashes++;\n      } else {\n        backSlashes = 0;\n      }\n  \n      if (\n        previousBackSlashes % 2 === 0 &&\n        (currentCharacter === '\"' || currentCharacter === \"'\")\n      ) {\n        if (isInsideString === currentCharacter) {\n          isInsideString = false;\n        } else if (!isInsideString) {\n          isInsideString = currentCharacter;\n        }\n      }\n  \n      if (isInsideString) {\n        // keep full string value and don't parse it\n        currentCode += currentCharacter;\n        currentDeclaration.value += currentCharacter;\n      }\n      // Find beginning of `/*` type comment\n      else if (currentCharacter === '/' && cssString[index + 1] === '*') {\n        let index2 = index + 2;\n        isInsideComment = true;\n  \n        // Iterate over comment\n        for (; index2 < cssString.length; index2++) {\n          // Find end of comment\n          if (cssString[index2] === '*' && cssString[index2 + 1] === '/') {\n            isInsideComment = false;\n            if (cssString[index2 + 2] === '\\n') {\n              index2++;\n            } else if (cssString[index2 + 2] + cssString[index2 + 3] === '\\r\\n') {\n              index2 += 2;\n            }\n            break;\n          }\n        }\n        // Resume iteration over CSS string from the end of the comment\n        index = index2 + 1;\n        continue;\n      }\n      // find beginning of `//` type comment\n      else if (currentCharacter === '/' && cssString[index + 1] === '/') {\n        let index2 = index + 2;\n        isInsideComment = true;\n  \n        // Iterate over comment\n        for (; index2 < cssString.length; index2++) {\n          // Find end of comment\n          if (cssString[index2] === '\\n') {\n            isInsideComment = false;\n            break;\n          }\n        }\n        // Resume iteration over CSS string from the end of the comment\n        index = index2 + 1;\n        continue;\n      }\n      // check if the current selector got closed\n      // closes also the current declaration\n      else if (currentCharacter === '}') {\n        currentScopes.pop();\n        currentCode = '';\n        isInsidePropertyValue = false;\n        currentDeclaration.scope = [...currentScopes];\n        if (currentDeclaration.property) {\n          currentDeclaration.closed = true;\n          currentDeclaration = newDeclaration();\n          declarations.push(currentDeclaration);\n        }\n      }\n      // check if the current selector got opened\n      else if (currentCharacter === '{') {\n        currentScopes.push({\n          name: currentCode.trim(),\n          type: isInsideAtRule ? 'at-rule' : 'selector',\n        });\n        currentCode = '';\n        isInsidePropertyValue = false;\n        isInsideAtRule = false;\n        currentDeclaration.property = '';\n        currentDeclaration.value = '';\n      }\n      // check if the current declaration got closed\n      else if (currentCharacter === ';') {\n        currentCode = '';\n        isInsidePropertyValue = false;\n        isInsideAtRule = false;\n        currentDeclaration.closed = true;\n        currentDeclaration.scope = [...currentScopes];\n        currentDeclaration = newDeclaration();\n        declarations.push(currentDeclaration);\n      }\n      // check for a property name\n      // caution - this might also be a selector like\n      // bar:hover\n      else if (\n        !isInsidePropertyValue &&\n        !isInsideAtRule &&\n        currentCharacter === ':'\n      ) {\n        isInsidePropertyValue = true;\n        currentCode += currentCharacter;\n      } else if (!isInsidePropertyValue && currentCharacter === '@') {\n        isInsideAtRule = true;\n        currentCode += currentCharacter;\n      }\n      // css code\n      else {\n        // don't keep multiple empty characters\n        const previousCharacter = index === 0 ? currentDeclaration.value.at(-1) : cssString[index - 1];\n\n        const isPreviousCharacterEmpty =\n          (index > 0 && !currentCode) ||\n          !previousCharacter ||\n          previousCharacter === ' ' ||\n          previousCharacter === '\\n' ||\n          previousCharacter === '\\r' ||\n          previousCharacter === '\\t';\n        const isCurrentCharacterEmpty =\n          currentCharacter === ' ' ||\n          currentCharacter === '\\n' ||\n          currentCharacter === '\\r' ||\n          currentCharacter === '\\t';\n\n        if (!isPreviousCharacterEmpty || !isCurrentCharacterEmpty) {\n          currentCode += currentCharacter;\n          if (isInsidePropertyValue) {\n            // prevent leading spaces in the value\n            if (!isCurrentCharacterEmpty || currentDeclaration.value) {\n              currentDeclaration.value += currentCharacter;\n            }\n          } else {\n            currentDeclaration.property += currentCharacter;\n          }\n        }\n      }\n    }\n  \n    // remove current declaration if it's empty\n    if (!currentDeclaration.property) {\n      declarations.pop();\n    }\n  \n    return {\n      state: {\n        isInsideString,\n        isInsideComment,\n        isInsidePropertyValue,\n        isInsideAtRule,\n        currentDeclaration,\n        currentScopes,\n      },\n      declarations,\n    };\n  }\n  ","import type { CssScope, Declaration } from './parseCss.js';\n\nexport const toCss = (declarations: Declaration[]): string => {\n  let css = '';\n  let previousScopes: CssScope[] = [];\n  for (const declaration of declarations) {\n    const scopes = declaration.scope\n    // close scopes that are not in the current declaration\n    for (let i = 0; i < previousScopes.length; i++) {\n      if (\n        !scopes[i] ||\n        scopes[i].name !== previousScopes[i].name ||\n        scopes[i].type !== previousScopes[i].type\n      ) {\n        for (let j = previousScopes.length - 1; j >= i; j--) {\n            css += '\\n' + '  '.repeat(j) + '}';\n        }\n        break;\n      }\n    }\n    // open scopes that are not in the previous declaration\n    for (let i = 0; i < scopes.length; i++) {\n      if (\n        !previousScopes[i] ||\n        scopes[i].name !== previousScopes[i].name ||\n        scopes[i].type !== previousScopes[i].type\n      ) {\n        for (let j = i; j < scopes.length; j++) {\n            css += '\\n' + '  '.repeat(j) + scopes[j].name + ' {';\n        }\n        break;\n      }\n    }\n    css += `\\n${'  '.repeat(scopes.length)}${\n      declaration.property\n    }: ${declaration.value};`;\n    previousScopes = scopes;\n  }\n  // close all scopes\n  for (let i = previousScopes.length - 1; i >= 0; i--) {\n    css += '\\n' + '  '.repeat(i) + '}';\n  }\n\n  return css;\n};\n","import type { types as babelTypes } from \"@babel/core\";\n\n/**\n * Extracts the css unit from a css string and checks if it is a valid CSS unit\n */\nconst appendCssUnitToExpressionValue = (\n  cssUnit: string,\n  expression: babelTypes.Expression,\n  runtimeInternalHelpers: Set<string>,\n  t: typeof babelTypes\n) => {\n  if (expression.type === \"ArrowFunctionExpression\") {\n    if (expression.body.type !== \"BlockStatement\") {\n      const newBody = t.binaryExpression(\n        \"+\",\n        t.parenthesizedExpression(expression.body),\n        t.stringLiteral(cssUnit)\n      );\n\n      const newArrowFunction = t.arrowFunctionExpression(\n        expression.params,\n        newBody\n      );\n      return newArrowFunction;\n    }\n  } else if (\n    expression.type === \"NumericLiteral\" ||\n    expression.type === \"BinaryExpression\" ||\n    expression.type === \"Identifier\"\n  ) {\n    const cssUnitLiteral = t.stringLiteral(cssUnit);\n    const binaryExpression = t.binaryExpression(\n      \"+\",\n      expression,\n      cssUnitLiteral\n    );\n    return binaryExpression;\n  }\n\n  const callExpression = t.callExpression(t.identifier(\"__yak_unitPostFix\"), [\n    expression,\n    t.stringLiteral(cssUnit),\n  ]);\n  runtimeInternalHelpers.add(\"__yak_unitPostFix\");\n  return callExpression;\n};\n\nexport default appendCssUnitToExpressionValue;\n","import type babelCore from \"@babel/core\";\nimport {\n  BabelFile,\n  NodePath,\n  PluginObj,\n  PluginPass,\n  types as babelTypes,\n} from \"@babel/core\";\nimport { TaggedTemplateExpression } from \"@babel/types\";\nimport { basename, relative, resolve } from \"node:path\";\nimport { getConstantName, getConstantValues } from \"./lib/getConstantValues.js\";\nimport murmurhash2_32_gc from \"./lib/hash.js\";\nimport replaceQuasiExpressionTokens from \"./lib/replaceQuasiExpressionTokens.js\";\nimport getStyledComponentName from \"./lib/getStyledComponentName.js\";\nimport getCssName from \"./lib/getCssName.js\";\nimport { Declaration, ParserState, parseCss } from \"./lib/parseCss.js\";\nimport { toCss } from \"./lib/toCss.js\";\nimport appendCssUnitToExpressionValue from \"./lib/appendCssUnitToExpressionValue.js\";\n\ntype YakBabelPluginOptions = {\n  replaces: Record<string, unknown>;\n  rootContext?: string;\n};\n\ntype YakLocalIdentifierNames = {\n  css: string | undefined;\n  styled: string | undefined;\n  keyframes: string | undefined;\n};\n\n// `YakTemplateLiteral` is an AST node for a `style` or `css` usage in the user code with its css code and expressions\ntype YakTemplateLiteral = {\n  name: string;\n  path: NodePath<babelTypes.TaggedTemplateExpression>;\n  hasParent: boolean;\n  cssPartQuasis: string[];\n  cssPartExpressions: { [key: number]: YakTemplateLiteral[] };\n  type:\n    | \"cssLiteral\"\n    | \"keyframesLiteral\"\n    | \"styledLiteral\"\n    | \"styledCall\"\n    | \"attrsCall\";\n};\n\n/**\n * Babel plugin for typescript files that use yak - it will do things:\n * - inject the import to the css-module (with .yak.module.css extension)\n * - replace the css template literal with styles from the css-module\n */\nexport default function (\n  babel: typeof babelCore,\n  options: YakBabelPluginOptions\n): PluginObj<\n  PluginPass & {\n    localVarNames: YakLocalIdentifierNames;\n    isImportedInCurrentFile: boolean;\n    topLevelConstBindings: ReturnType<typeof getConstantValues>;\n    variableNameToStyledCall: Map<\n      string,\n      {\n        wasAdded: boolean;\n        className: string;\n        astNode: babelTypes.CallExpression;\n      }\n    >;\n    yakImportPath?: NodePath<babelTypes.ImportDeclaration>;\n    yakTemplateExpressions: Map<\n      babelCore.NodePath<babelTypes.TaggedTemplateExpression>,\n      YakTemplateLiteral\n    >;\n  }\n> {\n  const { replaces } = options;\n  const rootContext = options.rootContext || process.cwd();\n  const { types: t } = babel;\n\n  /**\n   * A unique prefix for each file to avoid collisions\n   * (generated on first use by hashing the relative file path)\n   */\n  const hashedFilePaths = new WeakMap<BabelFile, string>();\n  const getHashedFilePath = (file: BabelFile) => {\n    const fromCache = hashedFilePaths.get(file);\n    if (fromCache) {\n      return fromCache;\n    }\n    const resourcePath = file.opts.filename;\n    if (!resourcePath) {\n      throw new Error(\"resourcePath is undefined\");\n    }\n    const relativePath = relative(\n      rootContext,\n      resolve(rootContext, resourcePath)\n    );\n    const hashedFilePath = murmurhash2_32_gc(relativePath);\n    hashedFilePaths.set(file, hashedFilePath);\n    return hashedFilePath;\n  };\n\n  /**\n   * Returns wether the given tag is matching a yak import\n   *\n   * e.g.:\n   * - css`...` -> cssLiteral\n   * - styled.div`...` -> styledLiteral\n   * - styled(Component)`...` -> styledCall\n   * - styled.div.attrs({})`...` -> attrsCall\n   * - keyframes`...` -> keyframesLiteral\n   */\n  const getYakExpressionType = (\n    tag: babelTypes.Expression,\n    localVarNames: YakLocalIdentifierNames\n  ) => {\n    if (t.isIdentifier(tag)) {\n      if (tag.name === localVarNames.css) {\n        return \"cssLiteral\";\n      }\n      if (tag.name === localVarNames.keyframes) {\n        return \"keyframesLiteral\";\n      }\n    }\n    if (\n      t.isMemberExpression(tag) &&\n      t.isIdentifier(tag.object) &&\n      tag.object.name === localVarNames.styled\n    ) {\n      return \"styledLiteral\";\n    }\n    if (\n      t.isCallExpression(tag) &&\n      t.isIdentifier(tag.callee) &&\n      tag.callee.name === localVarNames.styled\n    ) {\n      return \"styledCall\";\n    }\n    if (\n      t.isCallExpression(tag) &&\n      t.isMemberExpression(tag.callee) &&\n      t.isIdentifier(tag.callee.property) &&\n      tag.callee.property.name === \"attrs\"\n    ) {\n      return \"attrsCall\";\n    }\n    return \"unknown\";\n  };\n\n  return {\n    name: \"next-yak\",\n    pre() {\n      // Initialize state variables\n      this.localVarNames = {\n        css: undefined,\n        styled: undefined,\n        keyframes: undefined,\n      };\n      this.isImportedInCurrentFile = false;\n      this.variableNameToStyledCall = new Map();\n      this.topLevelConstBindings = new Map();\n      this.yakTemplateExpressions = new Map();\n    },\n    visitor: {\n      Program: {\n        enter(path) {\n          this.topLevelConstBindings = getConstantValues(path, t);\n        },\n        exit(path, state) {\n          if (!this.isImportedInCurrentFile) {\n            return;\n          }\n          const runtimeInternalHelpers = new Set<string>();\n          // Util to create a unique identifiers per file name\n          const existingNames = new Set<string>();\n          const createUniqueName = (name: string, hash?: boolean) => {\n            let i = 0;\n            let uniqueName = name;\n            while (existingNames.has(uniqueName)) {\n              i++;\n              uniqueName = `${name}_${i}`;\n            }\n            existingNames.add(uniqueName);\n            return hash\n              ? uniqueName + \"_\" + getHashedFilePath(state.file)\n              : uniqueName;\n          };\n          // Iteratate and transform all found yak template literals\n          visitYakExpression(\n            this.yakTemplateExpressions,\n            (expression, rootExpression, cssParserState, visitChildren) => {\n              transformYakExpressions(\n                expression,\n                rootExpression,\n                cssParserState,\n                visitChildren,\n                createUniqueName,\n                runtimeInternalHelpers,\n                getComponentTypes(this.yakTemplateExpressions),\n                this.topLevelConstBindings,\n                state.file\n              );\n            }\n          );\n\n          // Add used runtime helpers to the import\n          if (runtimeInternalHelpers.size && this.yakImportPath) {\n            const newImport = t.importDeclaration(\n              [...runtimeInternalHelpers].map((helper) =>\n                t.importSpecifier(t.identifier(helper), t.identifier(helper))\n              ),\n              t.stringLiteral(\"next-yak/runtime-internals\")\n            );\n            this.yakImportPath.insertAfter(newImport);\n          }\n        },\n      },\n      /**\n       * Store the name of the imported 'css' and 'styled' variables e.g.:\n       * - `import { css, styled } from 'next-yak'` -> { css: 'css', styled: 'styled' }\n       * - `import { css as yakCss, styled as yakStyled } from 'next-yak'` -> { css: 'yakCss', styled: 'yakStyled' }\n       *\n       * Inject the import to the css-module (with .yak.module.css extension)\n       * e.g. `import './App.yak.module.css!=!./App?./App.yak.module.css'`\n       */\n      ImportDeclaration(path, state) {\n        const node = path.node;\n        if (node.source.value !== \"next-yak\") {\n          return;\n        }\n        const filePath = state.file.opts.filename;\n        if (!filePath) {\n          throw new Error(\"filePath is undefined\");\n        }\n        const fileName = basename(filePath).replace(/\\.tsx?/, \"\");\n        // Import 'next-yak' styles and assign to '__styleYak'\n        // use webpacks !=! syntax to pretend that the typescript file is actually a css-module\n        path.insertAfter(\n          t.importDeclaration(\n            [t.importDefaultSpecifier(t.identifier(\"__styleYak\"))],\n            t.stringLiteral(\n              `./${fileName}.yak.module.css!=!./${fileName}?./${fileName}.yak.module.css`\n            )\n          )\n        );\n        this.yakImportPath = path;\n\n        // Process import specifiers\n        node.specifiers.forEach((specifier) => {\n          if (\n            !(\"imported\" in specifier) ||\n            !specifier.imported ||\n            !t.isIdentifier(specifier.imported)\n          ) {\n            return;\n          }\n\n          const importSpecifier = specifier.imported;\n          const localSpecifier = specifier.local || importSpecifier;\n\n          if (\n            importSpecifier.name === \"styled\" ||\n            importSpecifier.name === \"css\" ||\n            importSpecifier.name === \"keyframes\"\n          ) {\n            this.localVarNames[importSpecifier.name] = localSpecifier.name;\n            this.isImportedInCurrentFile = true;\n          }\n        });\n      },\n      /**\n       * Replace the tagged template expression\n       *  - css`...`\n       * - styled.div`...`\n       * - styled(Component)`...`\n       * - styled.div.attrs({})`...`\n       * - keyframes`...`\n       */\n      TaggedTemplateExpression(path, state) {\n        if (!this.isImportedInCurrentFile) {\n          return;\n        }\n        const tag = path.node.tag;\n\n        // Check if the tag name matches the imported 'css' or 'styled' variable\n        const expressionType = getYakExpressionType(tag, this.localVarNames);\n        if (expressionType === \"unknown\") {\n          return;\n        }\n\n        replaceQuasiExpressionTokens(\n          path.node.quasi,\n          (name) => {\n            // Replace constants from .yak files and\n            if (name in replaces) {\n              return replaces[name];\n            }\n            // Replace expressions by the className of the styled component\n            // e.g.\n            // const MyStyledDiv = styled.div`${FOO} { color: red; }`\n            // ->\n            // const MyStyledDiv = styled.div`.selector0 { color: red; }`\n            const styledCall = this.variableNameToStyledCall.get(name);\n            if (styledCall) {\n              const { wasAdded, className, astNode } = styledCall;\n              // on first usage of another styled component, ensure that\n              // the className of the target component will be added to the DOM\n              if (!wasAdded) {\n                styledCall.wasAdded = true;\n                astNode.arguments.unshift(\n                  t.memberExpression(\n                    t.identifier(\"__styleYak\"),\n                    t.identifier(className)\n                  )\n                );\n              }\n              return className;\n            }\n            return false;\n          },\n          t\n        );\n\n        const parentPosition = getClosestTemplateLiteralExpressionParentPath(\n          path,\n          this.yakTemplateExpressions\n        );\n\n        const name = !parentPosition\n          ? // root name e.g. const MyButton = styled.div`...` -> \"MyButton\"\n            getStyledComponentName(path)\n          : // nested name e.g. `... ${({$active}) => $active && css`color:red`} ...` -> \"active\"\n            getCssName(path);\n\n        const takTemplateExpression: YakTemplateLiteral = {\n          name,\n          path,\n          cssPartQuasis: path.node.quasi.quasis.map((quasi) => quasi.value.raw),\n          cssPartExpressions: {},\n          hasParent: Boolean(parentPosition?.parent),\n          type: expressionType,\n        };\n\n        const parent =\n          parentPosition?.parent &&\n          this.yakTemplateExpressions.get(parentPosition.parent);\n        if (parent) {\n          parent.cssPartExpressions[parentPosition.currentIndex] ||= [];\n          parent.cssPartExpressions[parentPosition.currentIndex].push(\n            takTemplateExpression\n          );\n        }\n\n        this.yakTemplateExpressions.set(path, takTemplateExpression);\n      },\n    },\n  };\n}\n\nexport class InvalidPositionError extends Error {\n  /**\n   * Add the expression code that caused the error to the message\n   * for better debugging\n   */\n  constructor(\n    message: string,\n    expression: babelTypes.Expression,\n    file: BabelFile,\n    recommendedFix?: string\n  ) {\n    let errorText = message;\n    const line = expression.loc?.start.line ?? -1;\n    if (line !== -1) {\n      errorText = `line ${line}: ${errorText}`;\n    }\n    if (expression.start && expression.end) {\n      errorText += `\\nfound: \\${${file.code.slice(\n        expression.start,\n        expression.end\n      )}}`;\n    }\n    if (recommendedFix) {\n      errorText += `\\n${recommendedFix}`;\n    }\n    super(errorText);\n  }\n}\n\n/**\n * Searches the closest parent TaggedTemplateExpression using a name from localNames\n * Returns the location inside this parent\n */\nconst getClosestTemplateLiteralExpressionParentPath = (\n  path: NodePath<TaggedTemplateExpression>,\n  knownParents: Map<\n    import(\"@babel/core\").NodePath<babelTypes.TaggedTemplateExpression>,\n    unknown\n  >\n) => {\n  let grandChild: NodePath = path;\n  let child: NodePath = path;\n  let parent = path.parentPath;\n  while (parent) {\n    if (\n      babelTypes.isTaggedTemplateExpression(parent.node) &&\n      knownParents.has(\n        parent as babelCore.NodePath<babelTypes.TaggedTemplateExpression>\n      )\n    ) {\n      if (\n        !babelTypes.isTemplateLiteral(child.node) ||\n        !babelTypes.isExpression(grandChild.node)\n      ) {\n        throw new Error(\"Unexpected Error - This AST structure is unexpected - please open an issue in the repository\");\n      }\n      const currentIndex = child.node.expressions.indexOf(grandChild.node);\n      return {\n        parent:\n          parent as babelCore.NodePath<babelTypes.TaggedTemplateExpression>,\n        currentIndex,\n      };\n    }\n    if (!parent.parentPath) {\n      return null;\n    }\n    grandChild = child;\n    child = parent;\n    parent = parent.parentPath;\n  }\n  return null;\n};\n\nfunction visitYakExpression(\n  yakTemplateExpressions: Map<\n    babelCore.NodePath<babelTypes.TaggedTemplateExpression>,\n    YakTemplateLiteral\n  >,\n  visitor: (\n    expression: YakTemplateLiteral,\n    rootExpression: YakTemplateLiteral,\n    cssParserState: ParserState,\n    visitChildren: (quasiIndex: number, cssParserState: ParserState) => void\n  ) => void\n) {\n  const rootYakTemplateExpressions = Array.from(\n    yakTemplateExpressions.values()\n  ).filter((expression) => !expression.hasParent);\n  const recursiveVisitor = (\n    expression: YakTemplateLiteral,\n    rootExpression: YakTemplateLiteral,\n    cssParserState: ParserState\n  ) => {\n    visitor(\n      expression,\n      rootExpression,\n      cssParserState,\n      (quasiIndex, cssParserState) => {\n        expression.cssPartExpressions[quasiIndex]?.forEach(\n          (childExpression) => {\n            recursiveVisitor(childExpression, rootExpression, cssParserState);\n          }\n        );\n      }\n    );\n  };\n  rootYakTemplateExpressions.forEach((expression) => {\n    const initialParserState = parseCss(\"\");\n    recursiveVisitor(expression, expression, initialParserState.state);\n  });\n}\n\nconst rootExpressionCssDeclarations = new WeakMap<\n  YakTemplateLiteral,\n  Declaration[]\n>();\nfunction transformYakExpressions(\n  expression: YakTemplateLiteral,\n  rootExpression: YakTemplateLiteral,\n  cssParserState: ParserState,\n  visitChildren: (quasiIndex: number, cssParserState: ParserState) => void,\n  createUniqueName: (name: string, hash?: boolean) => string,\n  runtimeInternalHelpers: Set<string>,\n  componentTypeMapping: Record<string, YakTemplateLiteral[\"type\"]>,\n  constantValues: ReturnType<typeof getConstantValues>,\n  file: BabelFile\n) {\n  // Get className / keyframes name\n  const identifier = createUniqueName(\n    expression === rootExpression\n      ? expression.name\n      : `${rootExpression.name}__${expression.name}`\n  );\n\n  // Initialize Declarations\n  const rootDeclarations =\n    rootExpressionCssDeclarations.get(rootExpression) || [];\n  if (rootExpression === expression) {\n    rootExpressionCssDeclarations.set(rootExpression, rootDeclarations);\n  }\n\n  // Arguments for the replaced styled call\n  const newArguments = new Set<babelTypes.Expression>();\n  const cssVariables: Record<string, babelCore.types.Expression> = {};\n  let addedOwnClassName = false;\n\n  let currentCssParserState = cssParserState;\n  // Iterate over the css parts\n  for (let i = 0; i < expression.cssPartQuasis.length; i++) {\n    let cssChunk = expression.cssPartQuasis[i].replace(/\\\\\\\\/g, \"\\\\\");\n    const quasiExpression = expression.path.node.quasi.expressions[i];\n\n    // Merge Component References directly into the css code before parsing\n    // e.g.:\n    // const Icon = styled.div``\n    // const Button = styled.button`&:${Icon} { color: red; }`\n    if (babelTypes.isIdentifier(quasiExpression)) {\n      let replaceValue: string | null = null;\n      // Component References\n      if (componentTypeMapping[quasiExpression.name]) {\n        if (componentTypeMapping[quasiExpression.name] === \"keyframesLiteral\") {\n          // Keyframes can be used as is e.g. animation: ${keyframes} 1s infinite;\n          replaceValue = quasiExpression.name;\n        } else if (\n          componentTypeMapping[quasiExpression.name] === \"styledLiteral\" ||\n          componentTypeMapping[quasiExpression.name] === \"styledCall\" ||\n          componentTypeMapping[quasiExpression.name] === \"attrsCall\"\n        ) {\n          // Styled components are referenced by their className\n          replaceValue = `.${quasiExpression.name}`;\n        }\n      }\n      // Constant values\n      else if (constantValues.has(quasiExpression.name)) {\n        const constantValue = constantValues.get(quasiExpression.name);\n        if (\n          !constantValue ||\n          (constantValue.type === \"variable\" && constantValue.value === null)\n        ) {\n          throw new InvalidPositionError(\n            `Could not resolve value for ${quasiExpression.name}`,\n            quasiExpression,\n            file\n          );\n        }\n        if (constantValue.type === \"module\") {\n          throw new InvalidPositionError(\n            `Imported values cannot be used as constants`,\n            quasiExpression,\n            file,\n            \"Move the constant into the current file or into a .yak file\"\n          );\n        }\n        if (constantValue.type === \"function\") {\n          throw new InvalidPositionError(\n            `Function constants are not supported yet`,\n            quasiExpression,\n            file\n          );\n        }\n        replaceValue = String(constantValue?.value);\n      }\n      // Identifier without program scope definition \n      // e.g. \n      // const Button = styled.button`$({$size}) => {\n      //    const ident = $size * 2 + \"px\";\n      //    return css`width: ${ident}`\n      // }`;\n      else {\n        // Allow the usage of the identifier for now\n      }\n      // Merge into next css chunk\n      if (replaceValue !== null) {\n        expression.cssPartQuasis[i + 1] =\n          expression.cssPartQuasis[i] +\n          replaceValue +\n          (expression.cssPartQuasis[i + 1] || \"\");\n        continue;\n      }\n    }\n\n    const parsedCss = parseCss(cssChunk, currentCssParserState);\n    currentCssParserState = parsedCss.state;\n\n    if (babelTypes.isTSType(quasiExpression)) {\n      throw new Error(\n        \"Type annotations are not allowed in css template literals\"\n      );\n    }\n\n    // If the styled component has any top-level css declarations\n    // the className must be added to the react component\n    if (parsedCss.declarations.length > 0 && !addedOwnClassName) {\n      newArguments.add(\n        babelTypes.memberExpression(\n          babelTypes.identifier(\"__styleYak\"),\n          babelTypes.identifier(identifier)\n        )\n      );\n      addedOwnClassName = true;\n    }\n    // Add a scope of the current css class name\n    const scopedDeclarations = parsedCss.declarations.map((declaration) => ({\n      ...declaration,\n      scope: [\n        expression.type === \"keyframesLiteral\"\n          ? { name: `@keyframes ${identifier}`, type: \"at-rule\" as const }\n          : { name: `.${identifier}`, type: \"selector\" as const },\n        ...declaration.scope,\n      ],\n    }));\n\n    // Handle expressions inside the css template literal\n    if (quasiExpression) {\n      // Convert expressions inside property values to css variables\n      // e.g.\n      // css`color: ${({$primary}) => $primary ? 'red' : 'blue'}`\n      if (currentCssParserState.isInsidePropertyValue) {\n        // Imported constants are not allowed inside property values\n        // technically this is supported however it is a bad practice\n        // as it creates the overhead of a css variable although the value\n        // is a constant\n        const constantName = getConstantName(quasiExpression, babelTypes);\n        if (\n            !babelTypes.isArrowFunctionExpression(quasiExpression)\n            && (\n            // On top level only arrow functions are allowed as css prop values\n              !expression.hasParent\n            ||\n            // Is using root constant inside for a css prop value:\n            // const primary = 'red';\n            // const Button = styled.button`color: ${({$primary}) => $primary && primaryColor}`\n              (constantName && constantValues.has(constantName))\n            )\n        ) { \n          throw new InvalidPositionError(\n            \"Possible constant used as runtime value for a css variable\",\n            quasiExpression,\n            file,\n            `Please move the constant to a .yak import or use an arrow function\ne.g.:\n|   import { primaryColor } from './foo.yak'\n|   const MyStyledDiv = styled.div\\`color: \\${primaryColor};\\``\n          );\n        }\n\n        const cssVarName = createUniqueName(\n          `${identifier}-${parsedCss.state.currentDeclaration.property}`,\n          true\n        );\n        cssVariables[`--${cssVarName}`] = quasiExpression;\n        currentCssParserState.currentDeclaration.value += `var(--${cssVarName})`;\n\n        // In styled components, css units can be after the expression\n        // e.g.:\n        // const MyButton = styled.button`width: ${({$width}) => $width}px`\n        // translating that to css variables would be: `width: var(--width)px`\n        // Unfortunately, this is not valid CSS, so we need to move the unit to the expression\n        const cssUnit =\n          expression.cssPartQuasis[i + 1]?.match(/^([a-z]+|%)/i)?.[0];\n        if (cssUnit) {\n          cssVariables[`--${cssVarName}`] = appendCssUnitToExpressionValue(\n            cssUnit,\n            quasiExpression,\n            runtimeInternalHelpers,\n            babelTypes\n          );\n          expression.cssPartQuasis[i + 1] = expression.cssPartQuasis[\n            i + 1\n          ].substring(cssUnit.length);\n        }\n\n        // The declaration is not closed yet so it should not be added to the rootDeclarations\n        scopedDeclarations.pop();\n      }\n      // Keep Mixin logic in js code\n      // e.g.:\n      // const mixin = ${({$primary}) => $primary ? css`color: red` : css`color: blue`};\n      else {\n        // Right now we can't recieve the value of imported mixin values\n        // This becomes a problem in nested selector scopes as we would have to merge\n        // the scopes and the css code\n        if (\n          currentCssParserState.currentScopes.length > 0 &&\n          quasiExpression.type !== \"TaggedTemplateExpression\" &&\n          quasiExpression.type !== \"ArrowFunctionExpression\"\n        ) {\n          throw new InvalidPositionError(\n            \"Mixins are not allowed inside nested selectors\",\n            quasiExpression,\n            file,\n            \"Use an inline css literal instead or move the selector into the mixin\"\n          );\n        }\n\n        // Add the expression to the arguments of the styled call\n        newArguments.add(quasiExpression);\n        // Remove semicolon from the following css part\n        // e.g.: css`color: ${({$primary}) => $primary ? 'red' : 'blue'};`\n        if (expression.cssPartQuasis[i + 1]?.startsWith(\";\")) {\n          expression.cssPartQuasis[i + 1] =\n            expression.cssPartQuasis[i + 1].substring(1);\n        }\n      }\n    }\n    // Store all css declarions for the rootDeclaration comment\n    rootDeclarations.push(...scopedDeclarations);\n    // Transform nested css`` literals\n    visitChildren(i, parsedCss.state);\n  }\n\n  // Merge all CSS Variables in one single object to reduce code size\n  // e.g.: { style: { \"--var\": expression, \"--var2\": expression } }\n  if (Object.keys(cssVariables).length) {\n    newArguments.add(\n      babelTypes.objectExpression([\n        babelTypes.objectProperty(\n          babelTypes.stringLiteral(`style`),\n          babelTypes.objectExpression(\n            Object.entries(cssVariables).map(([key, value]) =>\n              babelTypes.objectProperty(babelTypes.stringLiteral(key), value)\n            )\n          )\n        ),\n      ])\n    );\n  }\n\n  // Replace the css template literal with a function call\n  // to match the runtime api\n  expression.path.replaceWith(\n    babelTypes.callExpression(expression.path.node.tag, [...newArguments])\n  );\n  // Prepand the css as a comment to the styled component\n  // for later debugging and extraction\n  if (rootExpression === expression) {\n    const cssCode = toCss(rootDeclarations).trimStart();\n    if (cssCode) {\n      expression.path.addComment(\"leading\", \"YAK Extracted CSS:\\n\" + cssCode);\n    }\n  }\n}\n\nfunction getComponentTypes(\n  yakTemplateExpressions: Map<\n    babelCore.NodePath<babelTypes.TaggedTemplateExpression>,\n    YakTemplateLiteral\n  >\n) {\n  const nameTypeMap = Array.from(yakTemplateExpressions.values())\n    .filter((expression) => !expression.hasParent)\n    .map((expression) => [expression.name, expression.type] as const);\n  return Object.fromEntries(nameTypeMap);\n}\n","import tsloader from \"./tsloader.js\";\n\n/**\n * Transform typescript to css\n *\n * This loader reuses the yak tsloader and extracts the css from the generated comments\n */\nexport default async function cssloader(\n  this: any,\n  source: string\n): Promise<string | void> {\n  const callback = this.async();\n  return tsloader.call(\n    {\n      ...this,\n      async: () => (err: unknown | null, code?: string) => {\n        if (err || !code) {\n          return callback(err || new Error(\"No code returned\"));\n        }\n        return callback(null, extractCss(code));\n      },\n    },\n    source\n  );\n}\n\nfunction extractCss(code: string): string {\n  const codeParts = code.split(\"/*YAK Extracted CSS:\\n\");\n  let result = \"\";\n  for (let i = 1; i < codeParts.length; i++) {\n    const codeUntilEnd = codeParts[i].split(\"*/\")[0];\n    result += codeUntilEnd;\n  }\n  return result;\n}\n","import babel, { BabelFileResult } from \"@babel/core\";\nimport getYakImports from \"./lib/getYakImports.js\";\nimport { InvalidPositionError } from \"./babel-yak-plugin.js\";\n\n/**\n * Loader for typescript files that use yak, it replaces the css template literal with a call to the 'styled' function\n */\nexport default async function tsloader(\n  this: any,\n  source: string\n): Promise<string | void> {\n  // ignore files if they don't use yak\n  if (!source.includes(\"next-yak\")) {\n    return source;\n  }\n  const callback = this.async();\n  const { rootContext, resourcePath } = this;\n\n  /** .yak files are constant definition files */\n  const isYakFile = /\\.yak\\.(j|t)sx?$/.test(resourcePath.matches);\n  // The user may import constants from a .yak file\n  // e.g. import { primary } from './colors.yak'\n  //\n  // However .yak files inside .yak files are not be compiled\n  // to avoid performance overhead\n  const importedYakConstants = isYakFile ? [] : getYakImports(source);\n  const replaces: Record<string, unknown> = {};\n  await Promise.all(\n    importedYakConstants.map(async ({ imports, from }) => {\n      const constantValues = await this.importModule(from, {\n        layer: \"yak-importModule\",\n      });\n      imports.forEach(({ localName, importedName }) => {\n        replaces[localName] = constantValues[importedName];\n      });\n    })\n  );\n\n  let result: BabelFileResult | null = null;\n  try {\n    // Compile the typescript file with babel - this will:\n    // - inject the import to the css-module (with .yak.module.css extension)\n    // - replace the css template literal with styles from the css-module\n    result = babel.transformSync(source, {\n      filename: resourcePath,\n      configFile: false,\n      plugins: [\n        [\n          \"@babel/plugin-syntax-typescript\",\n          { isTSX: this.resourcePath.endsWith(\".tsx\") },\n        ],\n        [\n          await import(\"./babel-yak-plugin.js\").then((m) => m.default),\n          {\n            replaces,\n            rootContext,\n          },\n        ],\n      ],\n    });\n  } catch (error) {\n    if (error instanceof InvalidPositionError) {\n      return callback(new Error(error.message));\n    }\n    return callback(error instanceof Error ? error : new Error(\"babel transform failed\"));\n  }\n  if (!result?.code) {\n    return callback(new Error(\"babel transform failed\"));\n  }\n  return callback(null, result.code, result.map);\n}\n","/**\n * Finds all imports in a given code string which import from a .yak file\n *\n * Uses regex to work with typescript and javascript\n * Does not support lazy imports\n */\nconst getYakImports = (code: string) => {\n  const codeWithoutComments = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n  const allImports = codeWithoutComments.matchAll(\n    /(^|\\n|;)\\s*import\\s+(?:(\\w+(?:\\s+as\\s+\\w+)?)\\s*,?\\s*)?(?:{([^}]*)})?\\s+from\\s+[\"']([^'\"]+\\.yak)[\"'](;|\\n)/g\n  );\n  return [...allImports].map(([, , defaultImport, namedImports, from]) => {\n    // parse named imports to { localName: string, importedName: string }[]\n    const imports =\n      namedImports?.split(\",\").map((namedImport) => {\n        const [importedName, localName = importedName] = namedImport\n          .replace(/^type\\s+/, \"\")\n          .trim()\n          .split(/\\s+as\\s+/);\n        return { localName, importedName };\n      }) ?? [];\n    // parse default import to { localName: string, importedName: string }[]\n    if (defaultImport) {\n      imports.push(parseDefaultImport(defaultImport));\n    }\n    return { imports, from };\n  });\n};\n\n/**\n * Parses a default import string\n */\nfunction parseDefaultImport(defaultImport: string) {\n  const defaultImportArray = defaultImport.split(/\\s+as\\s+/);\n  return {\n    localName: defaultImportArray[1] ?? defaultImportArray[0],\n    importedName: defaultImportArray[0],\n  };\n}\n\nexport default getYakImports;\n"],"mappings":"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","names":["getStyledComponentName","babel","name","cssParserState","babelTypes","import_core","babel"]}