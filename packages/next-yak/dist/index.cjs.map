{"version":3,"sources":["../runtime/index.ts","../runtime/cssLiteral.tsx","../runtime/styled.tsx","../runtime/atoms.tsx","../runtime/keyframes.tsx"],"sourcesContent":["export { css } from \"./cssLiteral.js\";\nexport { styled } from \"./styled.js\";\nexport { atoms } from \"./atoms.js\";\nexport { keyframes } from \"./keyframes.js\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nexport { useTheme, YakThemeProvider } from \"next-yak/context\";\n\nexport type { YakTheme } from \"./context/index.d.ts\";\n","import type { YakTheme } from \"./index.d.ts\";\n\ntype ComponentStyles<TProps = {}> = (props: TProps) => {\n  className: string;\n  style?: {\n    [key: string]: string;\n  };\n};\n\nexport type CSSInterpolation<TProps = {}> =\n  | string\n  | number\n  | undefined\n  | null\n  | false\n  | ComponentStyles<TProps>\n  | ((props: TProps) => CSSInterpolation<TProps>);\n\ntype CSSStyles<TProps = {}> = {\n  style: { [key: string]: string | ((props: TProps) => string) };\n};\n\ntype CSSFunction = <TProps = {}>(\n  styles: TemplateStringsArray,\n  ...values: CSSInterpolation<TProps & { theme: YakTheme }>[]\n) => ComponentStyles<TProps>;\n\n/**\n * css() runtime factory of css``\n *\n * /!\\ next-yak transpiles css`` and styled``\n *\n * This changes the typings of the css`` and styled`` functions.\n * During development the user of next-yak wants to work with the\n * typings BEFORE compilation.\n *\n * Therefore this is only an internal function only and it must be cast to any\n * before exported to the user.\n */\nconst internalCssFactory = (\n  ...args: Array<string | CSSFunction | CSSStyles<any>>\n) => {\n  type PropsToClassNameFn = (props: unknown) => {\n    className?: string;\n    style?: Record<string, string>;\n  };\n  const classNames: string[] = [];\n  const dynamicCssFunctions: PropsToClassNameFn[] = [];\n  const style: Record<string, string> = {};\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (typeof arg === \"string\") {\n      classNames.push(arg);\n    } else if (typeof arg === \"function\") {\n      dynamicCssFunctions.push(arg as unknown as PropsToClassNameFn);\n    } else if (typeof arg === \"object\" && \"style\" in arg) {\n      for (const key in arg.style) {\n        const value = arg.style[key];\n        if (typeof value === \"function\") {\n          dynamicCssFunctions.push((props: unknown) => ({\n            style: { [key]: String(recursivePropExecution(props, value)) },\n          }));\n        } else {\n          style[key] = value;\n        }\n      }\n    }\n  }\n\n  // Non Dynamic CSS\n  if (dynamicCssFunctions.length === 0) {\n    const className = classNames.join(\" \");\n    return () => ({ className, style });\n  }\n\n  // Dynamic CSS with runtime logic\n  const unwrapProps = (\n    props: unknown,\n    fn: PropsToClassNameFn,\n    classNames: string[],\n    style: Record<string, string>,\n  ) => {\n    const result = fn(props);\n    if (typeof result === \"function\") {\n      unwrapProps(props, result, classNames, style);\n    } else if (typeof result === \"object\" && result) {\n      if (\"className\" in result && result.className) {\n        classNames.push(result.className);\n      }\n      if (\"style\" in result && result.style) {\n        for (const key in result.style) {\n          const value = result.style[key];\n          style[key] = value;\n        }\n      }\n    }\n  };\n\n  return (props: unknown) => {\n    const allClassNames: string[] = [...classNames];\n    const allStyles: Record<string, string> = { ...style };\n    for (let i = 0; i < dynamicCssFunctions.length; i++) {\n      unwrapProps(props, dynamicCssFunctions[i], allClassNames, allStyles);\n    }\n    return {\n      className: allClassNames.join(\" \"),\n      style: allStyles,\n    };\n  };\n};\n\nconst recursivePropExecution = (\n  props: unknown,\n  fn: (props: unknown) => any,\n): string | number => {\n  const result = fn(props);\n  if (typeof result === \"function\") {\n    return recursivePropExecution(props, result);\n  }\n  if (process.env.NODE_ENV === \"development\") {\n    if (\n      typeof result !== \"string\" &&\n      typeof result !== \"number\" &&\n      !(result instanceof String)\n    ) {\n      throw new Error(\n        `Dynamic CSS functions must return a string or number but returned ${JSON.stringify(\n          result,\n        )}`,\n      );\n    }\n  }\n  return result;\n};\n\nexport const css = internalCssFactory as any as CSSFunction;\n","import { ForwardRefRenderFunction, FunctionComponent } from \"react\";\nimport { CSSInterpolation, css } from \"./cssLiteral.js\";\nimport React from \"react\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nimport { useTheme } from \"next-yak/context\";\nimport type { YakTheme } from \"./context/index.d.ts\";\n\n/**\n * Hack to hide .yak from the type definition and to deal with ExoticComponents\n */\nconst yakForwardRef: <TProps>(\n  component: ForwardRefRenderFunction<any, TProps>,\n) => FunctionComponent<TProps> = (component) =>\n  Object.assign(React.forwardRef(component), { component }) as any;\n\n/**\n * All valid html tags\n */\ntype HtmlTags = keyof JSX.IntrinsicElements;\n\n/**\n * Return type of the provided props merged with the initial props\n * where the specified props are optional\n */\ntype AttrsMerged<TBaseProps, TIn extends object = {}> = Substitute<\n  TBaseProps & { theme: YakTheme },\n  TIn\n>;\n\n/**\n * The attrs function allows to add additional props to a styled component.\n * The props can be specified as an object or as a function that receives the\n * current props as argument.\n */\ntype Attrs<\n  TBaseProps,\n  TIn extends object = {},\n  TOut extends AttrsMerged<TBaseProps, TIn> = AttrsMerged<TBaseProps, TIn>,\n> =\n  | Partial<TOut>\n  | ((p: Substitute<TBaseProps & { theme: YakTheme }, TIn>) => Partial<TOut>);\n\n//\n// The `styled()` and `styled.` API\n//\n// The API design is inspired by styled-components:\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/constructors/styled.tsx\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/models/StyledComponent.ts\n//\n\nconst StyledFactory = <T,>(Component: HtmlTags | FunctionComponent<T>) =>\n  Object.assign(yakStyled(Component), {\n    attrs: <\n      TAttrsIn extends object = {},\n      TAttrsOut extends AttrsMerged<T, TAttrsIn> = AttrsMerged<T, TAttrsIn>,\n    >(\n      attrs: Attrs<T, TAttrsIn, TAttrsOut>,\n    ) => yakStyled<T, TAttrsIn, TAttrsOut>(Component, attrs),\n  });\n\nconst yakStyled = <\n  T,\n  TAttrsIn extends object = {},\n  TAttrsOut extends AttrsMerged<T, TAttrsIn> = AttrsMerged<T, TAttrsIn>,\n>(\n  Component: FunctionComponent<T> | HtmlTags,\n  attrs?: Attrs<T, TAttrsIn, TAttrsOut>,\n) => {\n  return <TCSSProps extends Record<string, unknown> = {}>(\n    styles: TemplateStringsArray,\n    ...values: Array<CSSInterpolation<T & TCSSProps & { theme: YakTheme }>>\n  ) => {\n    const getRuntimeStyles = css(styles, ...values);\n    const processAttrs = (props: Substitute<TCSSProps & T, TAttrsIn>) =>\n      combineProps(\n        props,\n        typeof attrs === \"function\" ? (attrs as Function)(props) : attrs,\n      );\n    const yak = (props: Substitute<TCSSProps & T, TAttrsIn>, ref: unknown) => {\n      /** The combined props are passed into the styled`` literal functions */\n      const combinedProps: Substitute<TCSSProps & T, TAttrsIn> = processAttrs(Object.assign(\n        // if the css component does not require arguments\n        // it can be call without arguments and skip calling useTheme()\n        //\n        // this is NOT against the rule of hooks as\n        // getRuntimeStyles is a constant defined outside of the component\n        //\n        // for example\n        //\n        // const Button = styled.button`color: red;`\n        //       ^ does not need to have access to theme\n        //\n        // const Button = styled.button`${({ theme }) => css`color: ${theme.color};`}`\n        //       ^ must be have acces to theme\n        attrs || getRuntimeStyles.length\n          ? { theme: useTheme() }\n          : {}, props) as Substitute<TCSSProps & T, TAttrsIn>,\n      );\n      // execute all functions inside the style literal\n      // e.g. styled.button`color: ${props => props.color};`\n      const runtimeStyles = getRuntimeStyles(combinedProps as any);\n\n      // remove all props that start with a $ sign for string components e.g. \"button\" or \"div\"\n      // so that they are not passed to the DOM element\n      const filteredProps =\n        typeof Component === \"string\"\n          ? removePrefixedProperties(combinedProps)\n          : combinedProps;\n\n      // yak provides a className and style prop that needs to be merged with the\n      // user provided className and style prop\n      (filteredProps as { className?: string }).className = mergeClassNames(\n        (combinedProps as { className?: string }).className,\n          runtimeStyles.className as string\n      );\n      (filteredProps as { style?: React.CSSProperties }).style = \"style\" in combinedProps ? {\n        ...(combinedProps as { style?: React.CSSProperties }).style,\n        ...(runtimeStyles.style || {}),\n      } : runtimeStyles.style;\n      // if the styled(Component) syntax is used and the component is a yak component\n      // we can call the yak function directly to avoid an unnecessary wrapper with an additional\n      // forwardRef call\n      if (typeof Component !== \"string\" && \"yak\" in Component) {\n        return (\n          Component as typeof Component & {\n            yak: FunctionComponent<typeof combinedProps>;\n          }\n        ).yak(filteredProps, ref);\n      }\n\n      (filteredProps as { ref?: unknown }).ref = ref;\n      return <Component {...(filteredProps as any)} />;\n    };\n    return yakForwardRef(yak);\n  };\n};\n\n/**\n * Type for the proxy object returned by `styled` that allows to\n * access all html tags as properties.\n */\ntype StyledLiteral<T> = <TCSSProps extends Record<string, unknown> = {}>(\n  styles: TemplateStringsArray,\n  ...values: Array<CSSInterpolation<T & TCSSProps & { theme: YakTheme }>>\n) => FunctionComponent<TCSSProps & T>;\n\n/**\n * The `styled` method works perfectly on all of your own or any third-party component,\n * as long as they attach the passed className prop to a DOM element.\n *\n * @usage\n *\n * ```tsx\n * const StyledLink = styled(Link)`\n *  color: #BF4F74;\n *  font-weight: bold;\n * `;\n * ```\n */\nexport const styled = new Proxy(\n  StyledFactory as typeof StyledFactory & {\n    [Tag in HtmlTags]: StyledLiteral<JSX.IntrinsicElements[Tag]> & {\n      attrs: <\n        TAttrsIn extends object = {},\n        TAttrsOut extends AttrsMerged<\n          JSX.IntrinsicElements[Tag],\n          TAttrsIn\n        > = AttrsMerged<JSX.IntrinsicElements[Tag], TAttrsIn>,\n      >(\n        attrs: Attrs<JSX.IntrinsicElements[Tag], TAttrsIn, TAttrsOut>,\n      ) => StyledLiteral<Substitute<JSX.IntrinsicElements[Tag], TAttrsIn>>;\n    };\n  },\n  {\n    get(target, TagName: keyof JSX.IntrinsicElements) {\n      return target(TagName);\n    },\n  },\n);\n\n// Remove all entries that start with a $ sign\nfunction removePrefixedProperties<T extends Record<string, unknown>>(obj: T) {\n  const result = {} as T;\n  for (const key in obj) {\n    if (!key.startsWith(\"$\") && key !== \"theme\") {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nconst mergeClassNames = (a?: string, b?: string) => {\n  if (!a) return b;\n  if (!b) return a;\n  return a + \" \" + b;\n};\n\nconst removeUndefined = <T,>(obj: T) => {\n  const result = {} as T;\n  for (const key in obj) {\n    if (obj[key] !== undefined) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n};\n\nconst combineProps = <\n  T extends {\n    className?: string;\n    style?: React.CSSProperties;\n  },\n>(\n  props: T,\n  newProps: T,\n) => {\n  if (!newProps) return props;\n  const combinedProps: T =\n    \"$__attrs\" in props\n      ? // allow overriding props when attrs was used previously\n        {\n          ...removeUndefined(newProps),\n          ...props,\n        }\n      : {\n          ...props,\n          ...removeUndefined(newProps),\n        };\n  return {\n    ...combinedProps,\n    className: mergeClassNames(\n      props.className as string,\n      newProps.className as string,\n    ),\n    style: { ...(props.style || {}), ...(newProps.style || {}) },\n    $__attrs: true,\n  };\n};\n\n// util type to remove properties from an object\ntype FastOmit<T extends object, U extends string | number | symbol> = {\n  [K in keyof T as K extends U ? never : K]: T[K];\n};\n\n// util type to merge two objects\n// if a property is present in both objects the property from B is used\nexport type Substitute<A extends object, B extends object> = FastOmit<\n  A,\n  keyof B\n> &\n  B;\n","/**\n * Allows to use atomic CSS classes in a styled or css block\n *\n * @usage\n *\n * ```tsx\n * import { styled, atoms } from \"next-yak\";\n *\n * const Button = styled.button<{ $primary?: boolean }>`\n *  ${atoms(\"text-teal-600\", \"text-base\", \"rounded-md\")}\n *  ${props => props.$primary && atoms(\"shadow-md\")}\n * `;\n * ```\n */\nexport const atoms = (...atoms: string[]) => {\n  const className = atoms.join(\" \");\n  return () => ({ className });\n};\n","/**\n * Allows to use CSS keyframe animations in a styled or css block\n *\n * @usage\n *\n * ```tsx\n * import { styled, keyframes } from \"next-yak\";\n *\n * const rotate = keyframes`\n *  from {\n *   transform: rotate(0deg);\n *  }\n *  to {\n *   transform: rotate(360deg);\n *  }\n * `;\n *\n * const Spinner = styled.div`\n *   animation: ${rotate} 1s linear infinite;\n * `;\n * ```\n */\nexport const keyframes = (\n  styles: TemplateStringsArray,\n  ...dynamic: never[]\n): string => {\n  // during compilation all args of keyframe are compiled\n  // to a string which references the animation name\n  return styles as any as string;\n};\n"],"mappings":"0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,mDAAAE,EAAA,QAAAC,EAAA,cAAAC,EAAA,WAAAC,EAAA,yCAAAC,EAAAN,GCuCA,IAAMO,EAAqB,IACtBC,IACA,CAKH,IAAMC,EAAuB,CAAC,EACxBC,EAA4C,CAAC,EAC7CC,EAAgC,CAAC,EACvC,QAASC,EAAI,EAAGA,EAAIJ,EAAK,OAAQI,IAAK,CACpC,IAAMC,EAAML,EAAKI,CAAC,EAClB,GAAI,OAAOC,GAAQ,SACjBJ,EAAW,KAAKI,CAAG,UACV,OAAOA,GAAQ,WACxBH,EAAoB,KAAKG,CAAoC,UACpD,OAAOA,GAAQ,UAAY,UAAWA,EAC/C,QAAWC,KAAOD,EAAI,MAAO,CAC3B,IAAME,EAAQF,EAAI,MAAMC,CAAG,EACvB,OAAOC,GAAU,WACnBL,EAAoB,KAAMM,IAAoB,CAC5C,MAAO,CAAE,CAACF,CAAG,EAAG,OAAOG,EAAuBD,EAAOD,CAAK,CAAC,CAAE,CAC/D,EAAE,EAEFJ,EAAMG,CAAG,EAAIC,CAEjB,CAEJ,CAGA,GAAIL,EAAoB,SAAW,EAAG,CACpC,IAAMQ,EAAYT,EAAW,KAAK,GAAG,EACrC,MAAO,KAAO,CAAE,UAAAS,EAAW,MAAAP,CAAM,EACnC,CAGA,IAAMQ,EAAc,CAClBH,EACAI,EACAX,EACAE,IACG,CACH,IAAMU,EAASD,EAAGJ,CAAK,EACvB,GAAI,OAAOK,GAAW,WACpBF,EAAYH,EAAOK,EAAQZ,EAAYE,CAAK,UACnC,OAAOU,GAAW,UAAYA,IACnC,cAAeA,GAAUA,EAAO,WAClCZ,EAAW,KAAKY,EAAO,SAAS,EAE9B,UAAWA,GAAUA,EAAO,OAC9B,QAAWP,KAAOO,EAAO,MAAO,CAC9B,IAAMN,EAAQM,EAAO,MAAMP,CAAG,EAC9BH,EAAMG,CAAG,EAAIC,CACf,CAGN,EAEA,OAAQC,GAAmB,CACzB,IAAMM,EAA0B,CAAC,GAAGb,CAAU,EACxCc,EAAoC,CAAE,GAAGZ,CAAM,EACrD,QAAS,EAAI,EAAG,EAAID,EAAoB,OAAQ,IAC9CS,EAAYH,EAAON,EAAoB,CAAC,EAAGY,EAAeC,CAAS,EAErE,MAAO,CACL,UAAWD,EAAc,KAAK,GAAG,EACjC,MAAOC,CACT,CACF,CACF,EAEMN,EAAyB,CAC7BD,EACAI,IACoB,CACpB,IAAMC,EAASD,EAAGJ,CAAK,EACvB,GAAI,OAAOK,GAAW,WACpB,OAAOJ,EAAuBD,EAAOK,CAAM,EAE7C,GAAI,QAAQ,IAAI,WAAa,eAEzB,OAAOA,GAAW,UAClB,OAAOA,GAAW,UAClB,EAAEA,aAAkB,QAEpB,MAAM,IAAI,MACR,qEAAqE,KAAK,UACxEA,CACF,CAAC,EACH,EAGJ,OAAOA,CACT,EAEaG,EAAMjB,ECrInB,IAAAkB,EAAkB,sBAKlBC,EAAyB,4BAMnBC,EAE4BC,GAChC,OAAO,OAAO,EAAAC,QAAM,WAAWD,CAAS,EAAG,CAAE,UAAAA,CAAU,CAAC,EAqCpDE,EAAqBC,GACzB,OAAO,OAAOC,EAAUD,CAAS,EAAG,CAClC,MAIEE,GACGD,EAAkCD,EAAWE,CAAK,CACzD,CAAC,EAEGD,EAAY,CAKhBD,EACAE,IAEO,CACLC,KACGC,IACA,CACH,IAAMC,EAAmBC,EAAIH,EAAQ,GAAGC,CAAM,EACxCG,EAAgBC,GACpBC,EACED,EACA,OAAON,GAAU,WAAcA,EAAmBM,CAAK,EAAIN,CAC7D,EAwDF,OAAON,EAvDK,CAACY,EAA4CE,IAAiB,CAExE,IAAMC,EAAqDJ,EAAa,OAAO,OAc7EL,GAASG,EAAiB,OACtB,CAAE,SAAO,YAAS,CAAE,EACpB,CAAC,EAAGG,CAAK,CACf,EAGMI,EAAgBP,EAAiBM,CAAoB,EAIrDE,EACJ,OAAOb,GAAc,SACjBc,EAAyBH,CAAa,EACtCA,EAeN,OAXCE,EAAyC,UAAYE,EACnDJ,EAAyC,UACxCC,EAAc,SAClB,EACCC,EAAkD,MAAQ,UAAWF,EAAgB,CACpF,GAAIA,EAAkD,MACtD,GAAIC,EAAc,OAAS,CAAC,CAC9B,EAAIA,EAAc,MAId,OAAOZ,GAAc,UAAY,QAASA,EAE1CA,EAGA,IAAIa,EAAeH,CAAG,GAGzBG,EAAoC,IAAMH,EACpC,EAAAZ,QAAA,cAACE,EAAA,CAAW,GAAIa,EAAuB,EAChD,CACwB,CAC1B,EAyBWG,EAAS,IAAI,MACxBjB,EAaA,CACE,IAAIkB,EAAQC,EAAsC,CAChD,OAAOD,EAAOC,CAAO,CACvB,CACF,CACF,EAGA,SAASJ,EAA4DK,EAAQ,CAC3E,IAAMC,EAAS,CAAC,EAChB,QAAWC,KAAOF,EACZ,CAACE,EAAI,WAAW,GAAG,GAAKA,IAAQ,UAClCD,EAAOC,CAAG,EAAIF,EAAIE,CAAG,GAGzB,OAAOD,CACT,CAEA,IAAML,EAAkB,CAACO,EAAYC,IAC9BD,EACAC,EACED,EAAI,IAAMC,EADFD,EADAC,EAKXC,EAAuBL,GAAW,CACtC,IAAMC,EAAS,CAAC,EAChB,QAAWC,KAAOF,EACZA,EAAIE,CAAG,IAAM,SACfD,EAAOC,CAAG,EAAIF,EAAIE,CAAG,GAGzB,OAAOD,CACT,EAEMX,EAAe,CAMnBD,EACAiB,IAEKA,EAYE,CACL,GAXA,aAAcjB,EAEV,CACE,GAAGgB,EAAgBC,CAAQ,EAC3B,GAAGjB,CACL,EACA,CACE,GAAGA,EACH,GAAGgB,EAAgBC,CAAQ,CAC7B,EAGJ,UAAWV,EACTP,EAAM,UACNiB,EAAS,SACX,EACA,MAAO,CAAE,GAAIjB,EAAM,OAAS,CAAC,EAAI,GAAIiB,EAAS,OAAS,CAAC,CAAG,EAC3D,SAAU,EACZ,EApBsBjB,EC7MjB,IAAMkB,EAAQ,IAAIA,IAAoB,CAC3C,IAAMC,EAAYD,EAAM,KAAK,GAAG,EAChC,MAAO,KAAO,CAAE,UAAAC,CAAU,EAC5B,ECKO,IAAMC,EAAY,CACvBC,KACGC,IAIID,EJpBT,IAAAE,EAA2C","names":["runtime_exports","__export","atoms","css","keyframes","styled","__toCommonJS","internalCssFactory","args","classNames","dynamicCssFunctions","style","i","arg","key","value","props","recursivePropExecution","className","unwrapProps","fn","result","allClassNames","allStyles","css","import_react","import_context","yakForwardRef","component","React","StyledFactory","Component","yakStyled","attrs","styles","values","getRuntimeStyles","css","processAttrs","props","combineProps","ref","combinedProps","runtimeStyles","filteredProps","removePrefixedProperties","mergeClassNames","styled","target","TagName","obj","result","key","a","b","removeUndefined","newProps","atoms","className","keyframes","styles","dynamic","import_context"]}