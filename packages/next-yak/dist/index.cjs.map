{"version":3,"sources":["../runtime/index.ts","../runtime/cssLiteral.tsx","../runtime/styled.tsx","../runtime/atoms.tsx","../runtime/keyframes.tsx"],"sourcesContent":["export { css } from \"./cssLiteral.js\";\nexport { styled } from \"./styled.js\";\nexport { atoms } from \"./atoms.js\";\nexport { keyframes } from \"./keyframes.js\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nexport { useTheme, YakThemeProvider} from \"next-yak/context\"\n\nexport type { YakTheme } from \"./context/index.d.ts\";","import type { YakTheme } from \"./index.d.ts\";\n\ntype ComponentStyles<TProps extends {}> = (\n  props: TProps\n) => {\n  className: string;\n  style?: {\n    [key: string]: string;\n  };\n};\n\nexport type CSSInterpolation<TProps extends {}> =\n  | string\n  | number\n  | undefined\n  | null\n  | false\n  | ComponentStyles<TProps>\n  | ((props: TProps) => CSSInterpolation<TProps>);\n\ntype CSSStyles<TProps extends {}> = {\n  style: { [key: string]: string | ((props: TProps) => string) };\n};\n\ntype CSSFunction = <TProps extends {}>(\n  styles: TemplateStringsArray,\n  ...values: CSSInterpolation<TProps & {theme: YakTheme}>[]\n) => ComponentStyles<TProps>;\n\nconst internalImplementation = (\n  ...args: Array<string | CSSFunction | CSSStyles<any>>\n): ComponentStyles<any> => {\n  type PropsToClassNameFn = (props: unknown) => {\n    className?: string;\n    style?: Record<string, string>;\n  };\n  const classNames: string[] = [];\n  const dynamicCssFunctions: PropsToClassNameFn[] = [];\n  const style: Record<string, string> = {};\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (typeof arg === \"string\") {\n      classNames.push(arg);\n    } else if (typeof arg === \"function\") {\n      dynamicCssFunctions.push(arg as unknown as PropsToClassNameFn);\n    } else if (typeof arg === \"object\" && \"style\" in arg) {\n      for (const key in arg.style) {\n        const value = arg.style[key];\n        if (typeof value === \"function\") {\n          dynamicCssFunctions.push((props: unknown) => ({\n            style: { [key]: String(recursivePropExecution(props, value)) },\n          }));\n        } else {\n          style[key] = value;\n        }\n      }\n    }\n  }\n\n  // Non Dynamic CSS\n  if (dynamicCssFunctions.length === 0) {\n    const className = classNames.join(\" \");\n    return () => ({ className, style });\n  }\n\n  // Dynamic CSS with runtime logic\n  const unwrapProps = (\n    props: unknown,\n    fn: PropsToClassNameFn,\n    classNames: string[],\n    style: Record<string, string>\n  ) => {\n    const result = fn(props);\n    if (typeof result === \"function\") {\n      unwrapProps(props, result, classNames, style);\n    } else if (typeof result === \"object\" && result) {\n      if (\"className\" in result && result.className) {\n        classNames.push(result.className);\n      }\n      if (\"style\" in result && result.style) {\n        for (const key in result.style) {\n          const value = result.style[key];\n          style[key] = value;\n        }\n      }\n    }\n  };\n\n  return (props: unknown) => {\n    const allClassNames: string[] = [...classNames];\n    const allStyles: Record<string, string> = { ...style };\n    for (let i = 0; i < dynamicCssFunctions.length; i++) {\n      unwrapProps(props, dynamicCssFunctions[i], allClassNames, allStyles);\n    }\n    return {\n      className: allClassNames.join(\" \"),\n      style: allStyles,\n    };\n  };\n};\n\nconst recursivePropExecution = (\n  props: unknown,\n  fn: (props: unknown) => any,\n): string | number => {\n  const result = fn(props);\n  if (typeof result === \"function\") {\n    return recursivePropExecution(props, result);\n  }\n  if (process.env.NODE_ENV === \"development\") {\n    if (\n      typeof result !== \"string\" &&\n      typeof result !== \"number\" &&\n      !(result instanceof String)\n    ) {\n      throw new Error(\n        `Dynamic CSS functions must return a string or number but returned ${JSON.stringify(\n          result,\n        )}`,\n      );\n    }\n  }\n  return result;\n};\n\nexport const css = internalImplementation as any as CSSFunction;\n","import { ForwardRefRenderFunction, FunctionComponent } from \"react\";\nimport { CSSInterpolation, css } from \"./cssLiteral.js\";\nimport React from \"react\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nimport { useTheme } from \"next-yak/context\";\nimport type { YakTheme } from \"./context/index.d.ts\";\n\n//\n// The `styled()` and `styled.` API\n//\n// The API design is inspired by styled-components:\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/constructors/styled.tsx\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/models/StyledComponent.ts\n//\n\ntype HtmlTags = keyof JSX.IntrinsicElements;\ntype PropsOf<TComponent extends FunctionComponent<any>> = TComponent extends FunctionComponent<infer TProps> ? TProps : never;\n\ntype StyledLiteral<TBaseProps extends {}> = <TProps extends Record<string, unknown> = {}>(\n  styles: TemplateStringsArray,\n  ...values: CSSInterpolation<TBaseProps & TProps & { theme: YakTheme }>[]\n) => FunctionComponent<TBaseProps & TProps>\n\n/**\n * Hack to hide .yak from the type definition and to deal with ExoticComponents\n */\nconst yakForwardRef: <TProps>(component: ForwardRefRenderFunction<any, TProps>) => FunctionComponent<TProps> = (\n  component\n) => Object.assign(React.forwardRef(component), {component}) as any;\n\nconst StyledFactory = <TComponent extends HtmlTags | FunctionComponent<any>>(Component: TComponent) => {\n  type Props = TComponent extends HtmlTags ? JSX.IntrinsicElements[TComponent] : TComponent extends FunctionComponent<any> ? PropsOf<TComponent> : never;\n\n  const literal: StyledLiteral<Props> = (\n    styles,\n    ...values\n  ) => {\n    const yak = (props: Props, ref: unknown) => {\n      const propsWithTheme = { ...props, theme: useTheme() };\n      const runtimeStyles = css(styles, ...values)(propsWithTheme as any);\n      const filteredProps =\n        typeof Component === \"string\" ? removePrefixedProperties(props) : props;\n      const mergedProps = {\n        ...filteredProps,\n        style: { ...(props.style || {}), ...runtimeStyles.style },\n        className:\n          (props.className ? props.className + \" \" : \"\") +\n          runtimeStyles.className,\n      }\n      // if the styled(Component) syntax is used and the component is a yak component\n      // we can call the yak function directly to avoid an unnecessary wrapper with an additional\n      // forwardRef call\n      if (typeof Component !== \"string\" && \"yak\" in (Component as (FunctionComponent<any> & {yak?: FunctionComponent<any>}))) {\n        return (Component as (FunctionComponent<any> & {yak: FunctionComponent<any>})).yak(mergedProps, ref);\n      }\n      return (\n        // @ts-expect-error\n        <Component\n          ref={ref as any}\n          {...mergedProps}\n        />\n      );\n    };\n    return yakForwardRef(yak);\n  }\n\n  return literal;\n};\n\n/**\n * The `styled` method works perfectly on all of your own or any third-party component, \n * as long as they attach the passed className prop to a DOM element.\n * \n * @usage\n * \n * ```tsx\n * const StyledLink = styled(Link)`\n *  color: #BF4F74;\n *  font-weight: bold;\n * `;\n * ```\n */\nexport const styled = new Proxy(StyledFactory as typeof StyledFactory &\n  {\n    [TagName in HtmlTags]: ReturnType<typeof StyledFactory<TagName>>;\n  }, {\n  get(target, TagName: keyof JSX.IntrinsicElements) {\n    return target(TagName as keyof JSX.IntrinsicElements);\n  },\n})\n\n// Remove all entries that start with a $ sign\nfunction removePrefixedProperties<T extends Record<string, unknown>>(obj: T) {\n  const result = {} as T;\n  for (const key in obj) {\n    if (!key.startsWith(\"$\")) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n","/**\n * Allows to use atomic CSS classes in a styled or css block\n * \n * @usage\n * \n * ```tsx\n * import { styled, atoms } from \"next-yak\";\n * \n * const Button = styled.button<{ $primary?: boolean }>`\n *  ${atoms(\"text-teal-600\", \"text-base\", \"rounded-md\")}\n *  ${props => props.$primary && atoms(\"shadow-md\")}\n * `;\n * ```\n */\nexport const atoms = (...atoms: string[]) => {\n    const className = atoms.join(\" \");\n    return () => ({ className });\n};","/**\n * Allows to use CSS keyframe animations in a styled or css block\n * \n * @usage\n * \n * ```tsx\n * import { styled, keyframes } from \"next-yak\";\n * \n * const rotate = keyframes`\n *  from {\n *   transform: rotate(0deg);\n *  }\n *  to {\n *   transform: rotate(360deg);\n *  }\n * `;\n * \n * const Spinner = styled.div`\n *   animation: ${rotate} 1s linear infinite;\n * `;\n * ```\n */\nexport const keyframes = (styles: TemplateStringsArray, \n    ...dynamic: never[]\n    ): string => {\n    // during compilation all args of keyframe are compiled\n    // to a string which references the animation name  \n    return styles as any as string;\n};"],"mappings":"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","names":["runtime_exports","__export","atoms","css","keyframes","styled","__toCommonJS","internalImplementation","args","classNames","dynamicCssFunctions","style","i","arg","key","value","props","recursivePropExecution","className","unwrapProps","fn","result","allClassNames","allStyles","css","import_react","import_context","yakForwardRef","component","React","StyledFactory","Component","styles","values","props","ref","propsWithTheme","runtimeStyles","css","mergedProps","removePrefixedProperties","styled","target","TagName","obj","result","key","atoms","className","keyframes","styles","dynamic","import_context"]}