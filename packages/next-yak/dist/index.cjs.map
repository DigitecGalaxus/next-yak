{"version":3,"sources":["../runtime/index.ts","../runtime/cssLiteral.tsx","../runtime/styled.tsx","../runtime/atoms.tsx","../runtime/keyframes.tsx"],"sourcesContent":["export { css } from \"./cssLiteral.js\";\nexport { styled } from \"./styled.js\";\nexport { atoms } from \"./atoms.js\";\nexport { keyframes } from \"./keyframes.js\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nexport { useTheme, YakThemeProvider} from \"next-yak/context\"\n\nexport type { YakTheme } from \"./context/index.d.ts\";","import type { YakTheme } from \"./index.d.ts\";\n\ntype ComponentStyles<TProps extends Record<string, unknown>> = (\n  props: TProps\n) => {\n  className: string;\n  style?: {\n    [key: string]: string;\n  };\n};\n\nexport type CSSInterpolation<TProps extends Record<string, unknown>> =\n  | string\n  | number\n  | undefined\n  | null\n  | false\n  | ComponentStyles<TProps>\n  | ((props: TProps) => CSSInterpolation<TProps>);\n\ntype CSSStyles<TProps extends Record<string, unknown>> = {\n  style: { [key: string]: string | ((props: TProps) => string) };\n};\n\ntype CSSFunction = <TProps extends Record<string, unknown>>(\n  styles: TemplateStringsArray,\n  ...values: CSSInterpolation<TProps & {theme: YakTheme}>[]\n) => ComponentStyles<TProps>;\n\n/**\n * css() runtime factory of css``\n * \n * /!\\ next-yak transpiles css`` and styled``\n * \n * This changes the typings of the css`` and styled`` functions.\n * During development the user of next-yak wants to work with the\n * typings BEFORE compilation.\n * \n * Therefore this is internal function only and it must be cast to any \n * before exported to the user.\n */\nconst internalCssFactory = (\n  ...args: Array<string | CSSFunction | CSSStyles<any>>\n) => {\n  type PropsToClassNameFn = (props: unknown) => {\n    className?: string;\n    style?: Record<string, string>;\n  };\n  const classNames: string[] = [];\n  const dynamicCssFunctions: PropsToClassNameFn[] = [];\n  const style: Record<string, string> = {};\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (typeof arg === \"string\") {\n      classNames.push(arg);\n    } else if (typeof arg === \"function\") {\n      dynamicCssFunctions.push(arg as unknown as PropsToClassNameFn);\n    } else if (typeof arg === \"object\" && \"style\" in arg) {\n      for (const key in arg.style) {\n        const value = arg.style[key];\n        if (typeof value === \"function\") {\n          dynamicCssFunctions.push((props: unknown) => ({\n            style: { [key]: String(recursivePropExecution(props, value)) },\n          }));\n        } else {\n          style[key] = value;\n        }\n      }\n    }\n  }\n\n  // Non Dynamic CSS\n  if (dynamicCssFunctions.length === 0) {\n    const className = classNames.join(\" \");\n    return () => ({ className, style });\n  }\n\n  // Dynamic CSS with runtime logic\n  const unwrapProps = (\n    props: unknown,\n    fn: PropsToClassNameFn,\n    classNames: string[],\n    style: Record<string, string>\n  ) => {\n    const result = fn(props);\n    if (typeof result === \"function\") {\n      unwrapProps(props, result, classNames, style);\n    } else if (typeof result === \"object\" && result) {\n      if (\"className\" in result && result.className) {\n        classNames.push(result.className);\n      }\n      if (\"style\" in result && result.style) {\n        for (const key in result.style) {\n          const value = result.style[key];\n          style[key] = value;\n        }\n      }\n    }\n  };\n\n  return (props: unknown) => {\n    const allClassNames: string[] = [...classNames];\n    const allStyles: Record<string, string> = { ...style };\n    for (let i = 0; i < dynamicCssFunctions.length; i++) {\n      unwrapProps(props, dynamicCssFunctions[i], allClassNames, allStyles);\n    }\n    return {\n      className: allClassNames.join(\" \"),\n      style: allStyles,\n    };\n  };\n};\n\nconst recursivePropExecution = (\n  props: unknown,\n  fn: (props: unknown) => any,\n): string | number => {\n  const result = fn(props);\n  if (typeof result === \"function\") {\n    return recursivePropExecution(props, result);\n  }\n  if (process.env.NODE_ENV === \"development\") {\n    if (\n      typeof result !== \"string\" &&\n      typeof result !== \"number\" &&\n      !(result instanceof String)\n    ) {\n      throw new Error(\n        `Dynamic CSS functions must return a string or number but returned ${JSON.stringify(\n          result,\n        )}`,\n      );\n    }\n  }\n  return result;\n};\n\nexport const css = internalCssFactory as any as CSSFunction;\n","import React, { FunctionComponent } from \"react\";\nimport { CSSInterpolation, css } from \"./cssLiteral.js\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nimport { useTheme } from \"next-yak/context\";\nimport type { YakTheme } from \"./context/index.d.ts\";\n\n//\n// The `styled()` and `styled.` API\n//\n// The API design is inspired by styled-components:\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/constructors/styled.tsx\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/models/StyledComponent.ts\n//\n\ntype HtmlTags = keyof JSX.IntrinsicElements;\n\nfunction StyledFactory<THtmlTag extends HtmlTags>(\n  Component: THtmlTag\n): <TProps extends Record<string, unknown>>(\n  styles: TemplateStringsArray,\n  ...values: CSSInterpolation<TProps & { theme: YakTheme }>[]\n) => FunctionComponent<JSX.IntrinsicElements[THtmlTag] & TProps>;\nfunction StyledFactory(Component: string | FunctionComponent<any>) {\n  return <TProps extends Record<string, unknown>>(\n    styles: TemplateStringsArray,\n    ...values: CSSInterpolation<TProps>[]\n  ) => {\n    const getRuntimeStyles = css(styles, ...values);\n\n    const Yak = (props: TProps, ref: unknown) => {\n      const runtimeStyles = getRuntimeStyles(\n        // if the css component does not require arguments\n        // it can be call without arguments and skip calling useTheme()\n        //\n        // this is NOT against the rule of hooks as\n        // getRuntimeStyles is a constant defined outside of the component\n        (getRuntimeStyles.length\n          ? { ...props, theme: useTheme() }\n          : {}) as TProps\n      );\n      // props includes all values for the css and for the html\n      // however if Component is a string e.g. \"div\" only the html props should be passed\n      // \n      // similar to styled-components 6.0.0 all props that start with a $ sign are removed\n      const filteredProps =\n        typeof Component === \"string\" ? removePrefixedProperties(props) : props;\n      // merge the users props with the generated runtime className and style\n      const mergedProps = {\n        ...filteredProps,\n        style: { ...props.style as {}, ...runtimeStyles.style },\n        className:\n          (props.className ? props.className + \" \" : \"\") +\n          runtimeStyles.className,\n      };\n      // if the styled(Component) syntax is used and the component is a yak component\n      // we can call the yak function directly to avoid an unnecessary wrapper with an additional\n      // forwardRef call\n      if (\n        typeof Component !== \"string\" &&\n        \"Yak\" in\n          (Component as FunctionComponent<any> & {\n            Yak?: FunctionComponent<any>;\n          })\n      ) {\n        return (\n          Component as FunctionComponent<any> & { Yak: FunctionComponent<any> }\n        ).Yak(mergedProps, ref);\n      }\n      return <Component ref={ref as any} {...mergedProps} />;\n    };\n    return Object.assign(React.forwardRef(Yak), { Yak });\n  };\n}\n\n/**\n * The `styled` method works perfectly on all of your own or any third-party component,\n * as long as they attach the passed className prop to a DOM element.\n *\n * @usage\n *\n * ```tsx\n * const StyledLink = styled(Link)`\n *  color: #BF4F74;\n *  font-weight: bold;\n * `;\n * ```\n */\nexport const styled = new Proxy(StyledFactory, {\n  get(target, TagName) {\n    if (typeof TagName !== \"string\") {\n      throw new Error(\"Only string tags are supported\");\n    }\n    return target(TagName as keyof JSX.IntrinsicElements);\n  },\n}) as (<TBaseProps extends {}>(\n  Component: FunctionComponent<TBaseProps>\n) => <TProps extends {}>(\n  styles: TemplateStringsArray,\n  ...values: CSSInterpolation<TProps & { theme: YakTheme }>[]\n) => FunctionComponent<TBaseProps & TProps>) & {\n  [TagName in HtmlTags]: ReturnType<typeof StyledFactory<TagName>>;\n};\n\n// Remove all entries that start with a $ sign\nfunction removePrefixedProperties<T extends Record<string, unknown>>(obj: T) {\n  const result = {} as T;\n  for (const key in obj) {\n    if (!key.startsWith(\"$\")) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n","/**\n * Allows to use atomic CSS classes in a styled or css block\n * \n * @usage\n * \n * ```tsx\n * import { styled, atoms } from \"next-yak\";\n * \n * const Button = styled.button<{ $primary?: boolean }>`\n *  ${atoms(\"text-teal-600\", \"text-base\", \"rounded-md\")}\n *  ${props => props.$primary && atoms(\"shadow-md\")}\n * `;\n * ```\n */\nexport const atoms = (...atoms: string[]) => {\n    const className = atoms.join(\" \");\n    return () => ({ className });\n};","/**\n * Allows to use CSS keyframe animations in a styled or css block\n * \n * @usage\n * \n * ```tsx\n * import { styled, keyframes } from \"next-yak\";\n * \n * const rotate = keyframes`\n *  from {\n *   transform: rotate(0deg);\n *  }\n *  to {\n *   transform: rotate(360deg);\n *  }\n * `;\n * \n * const Spinner = styled.div`\n *   animation: ${rotate} 1s linear infinite;\n * `;\n * ```\n */\nexport const keyframes = (styles: TemplateStringsArray, \n    ...dynamic: never[]\n    ): string => {\n    // during compilation all args of keyframe are compiled\n    // to a string which references the animation name  \n    return styles as any as string;\n};"],"mappings":"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","names":["runtime_exports","__export","atoms","css","keyframes","styled","__toCommonJS","internalCssFactory","args","classNames","dynamicCssFunctions","style","i","arg","key","value","props","recursivePropExecution","className","unwrapProps","fn","result","allClassNames","allStyles","css","import_react","import_context","StyledFactory","Component","styles","values","getRuntimeStyles","css","Yak","props","ref","runtimeStyles","mergedProps","removePrefixedProperties","React","styled","target","TagName","obj","result","key","atoms","className","keyframes","styles","dynamic","import_context"]}